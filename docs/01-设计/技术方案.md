# PMC全流程图表界面应用软件技术方案

## 项目概述

### 项目名称
PMC全流程图表界面应用软件

### 项目目标
基于BD400原始订单表和现有PMC工作流程，开发一套完整的图表界面PMC管理应用软件，实现从订单接收到产品交付的全流程可视化管理，集成微信、手机、邮件的自动跟进与催办功能。

### 项目存储位置
- **开发软件存储**：S:\PG-PMC\project
- **项目数据位置**：S:\PG-PMC\AI调度表

### 技术愿景
- **可视化优先**：以图表界面为核心，提供直观的数据展示和操作体验
- **全流程覆盖**：从订单接收到产品交付的完整业务流程支持
- **智能催办**：集成多渠道自动跟进催办，提升工作效率
- **实时监控**：实时数据更新和状态监控，及时发现和处理异常
- **协同工作**：支持多部门协作的统一工作平台

### 架构原则
- **前端优先**：重点投入前端图表界面开发，提供优秀的用户体验
- **数据驱动**：以订单数据为核心，构建完整的数据流转体系
- **模块化设计**：采用组件化开发，各功能模块独立开发和维护
- **集成友好**：支持与现有系统的集成，降低实施成本
- **响应式设计**：支持PC端和移动端的响应式访问

## 1. 项目架构设计与技术选型

### 1.1 整体系统架构

```
┌─────────────────────────────────────────────────────────────┐
│                    用户界面层 (UI Layer)                      │
├─────────────────────────────────────────────────────────────┤
│  Web前端界面  │  移动端界面  │  图表组件库  │  响应式布局    │
├─────────────────────────────────────────────────────────────┤
│                   业务服务层 (Service Layer)                  │
├─────────────────────────────────────────────────────────────┤
│ 订单管理服务 │ 生产计划服务 │ 物料控制服务 │ 催办通知服务   │
├─────────────────────────────────────────────────────────────┤
│                   数据访问层 (Data Layer)                     │
├─────────────────────────────────────────────────────────────┤
│  数据库服务  │  缓存服务   │  文件存储   │  消息队列      │
├─────────────────────────────────────────────────────────────┤
│                   集成接口层 (Integration Layer)              │
├─────────────────────────────────────────────────────────────┤
│  微信API接口 │  短信API接口 │ 邮件API接口 │ Excel处理接口  │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 技术架构选型

#### 前端技术栈
- **核心框架**：React 18 + TypeScript 4.9+
- **UI组件库**：Ant Design Pro 6.x
- **状态管理**：Redux Toolkit + RTK Query
- **图表库**：ECharts 5.x + D3.js 7.x
- **路由管理**：React Router 6.x
- **构建工具**：Vite 4.x + ESBuild
- **代码规范**：ESLint + Prettier + Husky
- **样式方案**：CSS Modules + Less

#### 后端技术栈
- **开发框架**：Python 3.12 + Flask 3.0 (已配置)
- **数据处理**：Pandas 2.2 + NumPy 1.26 (已配置)
- **HTTP客户端**：Requests 2.31 (已配置)
- **文件监控**：Watchdog 4.0 (已配置)
- **日志系统**：Loguru 0.7 + 结构化日志 (已配置)
- **配置管理**：Python-dotenv + PyYAML (已配置)
- **JSON处理**：Orjson 3.9 (已配置)
- **系统监控**：Psutil 5.9 (已配置)
- **安全加密**：Cryptography 41.0 (已配置)
- **数据库**：SQLite (内置) / PostgreSQL (可扩展)
- **异步支持**：Asyncio (内置) / Aiohttp (可选)
- **认证授权**：JWT + OAuth2 (待实现)

#### 部署与运维
- **容器化**：Docker + Docker Compose (已配置)
- **开发环境**：Docker多环境支持 (开发/生产/监控)
- **反向代理**：Nginx
- **进程管理**：Docker容器管理 + 健康检查
- **监控系统**：内置监控服务 + Prometheus + Grafana (可选)
- **日志收集**：Loguru结构化日志 + 容器日志管理

### 1.3 系统架构设计原则

1. **分层架构**：清晰的分层设计，便于维护和扩展
2. **容器化优先**：基于Docker的容器化部署，确保环境一致性
3. **多环境支持**：开发、生产、监控环境隔离，支持并行开发
4. **数据驱动**：以数据为中心，确保数据一致性和完整性
5. **响应式设计**：支持多终端访问，提供一致的用户体验
6. **安全优先**：完善的认证授权机制，确保数据安全
7. **可观测性**：内置健康检查、日志管理和监控能力

## 2. 功能模块设计

### 2.1 核心功能模块

#### 2.1.1 订单管理模块
- **订单导入**：支持Excel文件批量导入订单数据
- **订单评审**：可配置的订单评审工作流
- **订单跟踪**：订单状态实时跟踪和更新
- **交期管理**：交期预警和调整功能
- **客户管理**：客户信息维护和历史订单查询

#### 2.1.2 生产计划模块
- **排程管理**：基于约束条件的智能排程
- **产能分析**：实时产能评估和瓶颈识别
- **工艺路线**：产品工艺路线配置和管理
- **甘特图**：可交互的生产计划甘特图
- **计划调整**：生产计划的动态调整和优化

#### 2.1.3 物料管理模块
- **BOM管理**：产品BOM结构维护和版本控制
- **库存管理**：实时库存监控和预警
- **采购管理**：采购计划生成和执行跟踪
- **供应商管理**：供应商信息和绩效管理
- **成本分析**：物料成本分析和优化建议

#### 2.1.4 进度跟踪模块
- **实时监控**：生产进度实时监控看板
- **异常预警**：生产异常自动识别和预警
- **质量跟踪**：质量检验结果跟踪
- **设备状态**：生产设备状态监控
- **人员管理**：生产人员排班和效率统计

#### 2.1.5 通知催办模块
- **多渠道通知**：微信、短信、邮件集成
- **智能催办**：基于规则的自动催办策略
- **消息模板**：可配置的消息模板库
- **发送记录**：通知发送历史和效果跟踪
- **升级机制**：未响应时的自动升级策略

#### 2.1.6 报表分析模块
- **生产报表**：生产效率、质量、成本分析
- **订单报表**：订单完成率、交期达成率统计
- **库存报表**：库存周转率、呆滞料分析
- **绩效报表**：部门和个人绩效评估
- **自定义报表**：用户自定义报表配置

### 2.2 辅助功能模块

#### 2.2.1 系统管理模块
- **用户管理**：用户账号、角色、权限管理
- **组织架构**：部门、岗位、人员信息管理
- **系统配置**：系统参数配置和维护
- **数据字典**：基础数据字典维护
- **操作日志**：用户操作日志记录和查询

#### 2.2.2 基础数据模块
- **产品信息**：产品基础信息维护
- **客户信息**：客户基础信息管理
- **供应商信息**：供应商基础信息管理
- **物料信息**：物料基础信息维护
- **工艺信息**：工艺路线和工序信息

## 3. 数据库设计

### 3.1 核心实体关系图

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   客户表    │    │   订单表    │    │   产品表    │
│ customers   │────│   orders    │────│  products   │
│             │    │             │    │             │
└─────────────┘    └─────────────┘    └─────────────┘
                           │                   │
                           │                   │
                    ┌─────────────┐    ┌─────────────┐
                    │  订单明细表  │    │   BOM表     │
                    │order_items  │    │    boms     │
                    │             │    │             │
                    └─────────────┘    └─────────────┘
                                              │
                                              │
                                       ┌─────────────┐
                                       │  BOM明细表  │
                                       │  bom_items  │
                                       │             │
                                       └─────────────┘
                                              │
                                              │
                                       ┌─────────────┐
                                       │   物料表    │
                                       │ materials   │
                                       │             │
                                       └─────────────┘
```

### 3.2 核心数据表设计

#### 3.2.1 订单相关表
```sql
-- 订单表
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    order_no VARCHAR(50) UNIQUE NOT NULL,
    customer_id INTEGER REFERENCES customers(id),
    order_date DATE NOT NULL,
    delivery_date DATE NOT NULL,
    total_amount DECIMAL(15,2),
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    priority VARCHAR(10) NOT NULL DEFAULT 'normal',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 订单明细表
CREATE TABLE order_items (
    id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(id),
    product_id INTEGER REFERENCES products(id),
    quantity INTEGER NOT NULL,
    unit_price DECIMAL(10,2),
    delivery_date DATE,
    status VARCHAR(20) NOT NULL DEFAULT 'pending'
);
```

#### 3.2.2 产品相关表
```sql
-- 产品表
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    product_code VARCHAR(50) UNIQUE NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    specifications JSONB,
    unit VARCHAR(10) NOT NULL,
    standard_cost DECIMAL(10,2),
    lead_time INTEGER,
    status VARCHAR(20) NOT NULL DEFAULT 'active'
);

-- BOM表
CREATE TABLE boms (
    id SERIAL PRIMARY KEY,
    bom_code VARCHAR(50) UNIQUE NOT NULL,
    product_id INTEGER REFERENCES products(id),
    version VARCHAR(20) NOT NULL,
    effective_date DATE,
    status VARCHAR(20) NOT NULL DEFAULT 'active'
);

-- BOM明细表
CREATE TABLE bom_items (
    id SERIAL PRIMARY KEY,
    bom_id INTEGER REFERENCES boms(id),
    material_id INTEGER REFERENCES materials(id),
    quantity DECIMAL(10,4) NOT NULL,
    unit VARCHAR(10) NOT NULL,
    scrap_rate DECIMAL(5,4) DEFAULT 0,
    position INTEGER
);
```

#### 3.2.3 生产相关表
```sql
-- 生产计划表
CREATE TABLE production_plans (
    id SERIAL PRIMARY KEY,
    plan_no VARCHAR(50) UNIQUE NOT NULL,
    order_item_id INTEGER REFERENCES order_items(id),
    planned_start_date DATE,
    planned_end_date DATE,
    planned_quantity INTEGER,
    actual_start_date DATE,
    actual_end_date DATE,
    actual_quantity INTEGER,
    status VARCHAR(20) NOT NULL DEFAULT 'planned'
);

-- 工艺路线表
CREATE TABLE process_routes (
    id SERIAL PRIMARY KEY,
    route_code VARCHAR(50) UNIQUE NOT NULL,
    product_id INTEGER REFERENCES products(id),
    version VARCHAR(20) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'active'
);

-- 工序表
CREATE TABLE process_steps (
    id SERIAL PRIMARY KEY,
    route_id INTEGER REFERENCES process_routes(id),
    step_no INTEGER NOT NULL,
    step_name VARCHAR(100) NOT NULL,
    work_center VARCHAR(50),
    setup_time INTEGER,
    process_time INTEGER,
    queue_time INTEGER
);
```

## 4. 业务流程设计

### 4.1 订单处理流程

```
开始 → 订单导入 → 订单验证 → 技术评审 → 商务评审 → 生产排程 → 物料计算 → 采购计划 → 生产执行 → 质量检验 → 包装发货 → 结束
  │        │        │        │        │        │        │        │        │        │        │        │
  │        ↓        ↓        ↓        ↓        ↓        ↓        ↓        ↓        ↓        ↓        │
异常处理 ← 数据校验 ← 技术确认 ← 价格确认 ← 产能确认 ← MRP计算 ← 供应商确认 ← 进度跟踪 ← 质量确认 ← 物流跟踪 ← 客户确认
```

### 4.2 生产计划流程

```
订单确认 → 产能评估 → 物料可用性检查 → 排程优化 → 计划发布 → 执行监控 → 异常处理 → 计划调整
    │          │           │             │        │        │        │        │
    ↓          ↓           ↓             ↓        ↓        ↓        ↓        ↓
  需求分析   瓶颈识别    库存检查      约束求解   工单下达   实时跟踪   预警通知   重新排程
```

### 4.3 物料控制流程

```
MRP计算 → 采购需求 → 供应商选择 → 采购下单 → 到货检验 → 入库管理 → 生产领料 → 库存监控
   │         │          │          │        │        │        │        │
   ↓         ↓          ↓          ↓        ↓        ↓        ↓        ↓
 需求汇总   需求确认    询价比价    订单跟踪   质量确认   库位管理   消耗跟踪   补货预警
```

### 4.4 通知催办流程

```
任务创建 → 责任人分配 → 截止时间设定 → 自动监控 → 预警通知 → 催办升级 → 完成确认
   │          │            │           │        │        │        │
   ↓          ↓            ↓           ↓        ↓        ↓        ↓
 任务定义   人员指派      时间规划     状态检查   消息发送   升级策略   结果反馈
```

## 5. 界面设计方案

### 5.1 主控制台设计

#### 5.1.1 整体布局
```
┌─────────────────────────────────────────────────────────────┐
│                        顶部导航栏                            │
├─────────────────────────────────────────────────────────────┤
│ 侧边栏 │                    主内容区                        │
│       │  ┌─────────────────────────────────────────────┐   │
│ 功能   │  │              KPI指标卡片                   │   │
│ 菜单   │  ├─────────────────────────────────────────────┤   │
│       │  │                                           │   │
│       │  │              甘特图区域                    │   │
│       │  │                                           │   │
│       │  ├─────────────────────────────────────────────┤   │
│       │  │  订单列表  │  任务队列  │  异常预警  │  进度  │   │
│       │  │           │           │           │  跟踪  │   │
└───────┴──┴───────────┴───────────┴───────────┴────────┴───┘
```

#### 5.1.2 关键组件设计

**KPI指标卡片**
- 订单完成率
- 交期达成率
- 库存周转率
- 生产效率
- 质量合格率

**甘特图组件**
- 支持拖拽调整
- 实时数据更新
- 多层级展示
- 关键路径标识
- 资源冲突提醒

### 5.2 订单管理界面

#### 5.2.1 订单列表页面
```
┌─────────────────────────────────────────────────────────────┐
│  搜索筛选栏  │  快速操作按钮  │  导入导出  │  批量操作     │
├─────────────────────────────────────────────────────────────┤
│                        订单数据表格                          │
│  订单号 │ 客户 │ 产品 │ 数量 │ 交期 │ 状态 │ 进度 │ 操作    │
│  ──────┼─────┼─────┼─────┼─────┼─────┼─────┼────────  │
│  O001  │ A公司│ P001│ 100 │12/31│ 生产│ 60% │查看/编辑  │
│  O002  │ B公司│ P002│ 200 │01/15│ 计划│ 20% │查看/编辑  │
└─────────────────────────────────────────────────────────────┘
```

#### 5.2.2 订单详情页面
- 基本信息展示
- 产品明细列表
- 生产进度跟踪
- 物料需求分析
- 质量检验记录
- 操作日志记录

### 5.3 生产计划界面

#### 5.3.1 甘特图视图
- 时间轴可缩放
- 任务依赖关系
- 资源分配显示
- 进度实时更新
- 拖拽调整支持

#### 5.3.2 看板视图
- 计划中、进行中、已完成
- 卡片式任务展示
- 拖拽状态变更
- 快速操作菜单

### 5.4 物料管理界面

#### 5.4.1 库存监控看板
- 库存水位图表
- 预警物料列表
- 采购在途统计
- 消耗趋势分析

#### 5.4.2 BOM管理界面
- 树形结构展示
- 版本对比功能
- 成本分析图表
- 替代料管理
## 6. Docker开发环境方案

### 6.1 容器化架构设计

#### 6.1.1 多环境容器配置
```yaml
# docker-compose.yml 配置说明
services:
  pmc-app:        # 生产环境容器
    ports: "8000:8000"
    environment: ENV=production
    
  pmc-dev:        # 开发环境容器
    ports: "8001:8000"
    environment: ENV=development
    volumes: 项目代码热重载
    
  pmc-monitor:    # 监控环境容器
    environment: ENV=monitor
    depends_on: pmc-app
```

#### 6.1.2 容器特性
- **基础镜像**：Python 3.12.7-slim
- **安全用户**：非root用户运行 (appuser:1000)
- **健康检查**：30秒间隔自动检查服务状态
- **数据持久化**：logs和data目录映射到宿主机
- **网络隔离**：独立的pmc-network网络

#### 6.1.3 开发环境优势
- **环境一致性**：开发、测试、生产环境完全一致
- **快速部署**：一键启动完整开发环境
- **资源隔离**：容器间资源隔离，避免冲突
- **版本管理**：Docker镜像版本化管理
- **扩展性**：支持水平扩展和负载均衡

### 6.2 容器启动与管理

#### 6.2.1 启动命令
```bash
# 启动开发环境
docker-compose up pmc-dev

# 启动生产环境
docker-compose up pmc-app

# 启动监控环境
docker-compose up pmc-monitor

# 启动所有服务
docker-compose up
```

#### 6.2.2 环境变量配置
- **PYTHONPATH=/app**：Python模块路径
- **PYTHONUNBUFFERED=1**：实时输出日志
- **ENV**：环境标识 (development/production/monitor)

#### 6.2.3 数据卷管理
- **代码卷**：开发环境支持代码热重载
- **数据卷**：持久化数据存储
- **日志卷**：集中化日志管理
- **虚拟环境**：避免依赖冲突

### 6.3 监控与健康检查

#### 6.3.1 健康检查机制
```dockerfile
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:8000/health', timeout=5)" || exit 1
```

#### 6.3.2 日志管理
- **结构化日志**：Loguru配置的JSON格式日志
- **日志轮转**：自动日志文件轮转和压缩
- **集中收集**：容器日志统一收集到宿主机
- **实时监控**：支持实时日志查看和分析

## 7. 技术实现方案

### 6.1 前端实现方案

#### 6.1.1 组件架构
```typescript
// 组件层次结构
App
├── Layout
│   ├── Header
│   ├── Sidebar
│   └── Content
├── Pages
│   ├── Dashboard
│   ├── Orders
│   ├── Production
│   ├── Materials
│   └── Reports
└── Components
    ├── Charts
    ├── Tables
    ├── Forms
    └── Common
```

#### 6.1.2 状态管理
```typescript
// Redux Store 结构
interface RootState {
  auth: AuthState;
  orders: OrdersState;
  production: ProductionState;
  materials: MaterialsState;
  notifications: NotificationsState;
  ui: UIState;
}
```

#### 6.1.3 图表组件封装
```typescript
// 甘特图组件接口
interface GanttChartProps {
  data: GanttData[];
  timeRange: [Date, Date];
  onTaskUpdate: (task: Task) => void;
  onTaskSelect: (taskId: string) => void;
  readonly?: boolean;
}

// KPI卡片组件接口
interface KPICardProps {
  title: string;
  value: number;
  unit?: string;
  trend?: 'up' | 'down' | 'stable';
  target?: number;
  format?: 'number' | 'percentage' | 'currency';
}
```

### 6.2 后端实现方案

#### 6.2.1 API设计规范
```python
# RESTful API 设计
GET    /api/v1/orders              # 获取订单列表
POST   /api/v1/orders              # 创建新订单
GET    /api/v1/orders/{id}         # 获取订单详情
PUT    /api/v1/orders/{id}         # 更新订单
DELETE /api/v1/orders/{id}         # 删除订单

GET    /api/v1/orders/{id}/items   # 获取订单明细
POST   /api/v1/orders/{id}/items   # 添加订单明细
```

#### 6.2.2 数据模型定义
```python
# SQLAlchemy 模型示例
class Order(BaseModel):
    __tablename__ = 'orders'
    
    id = Column(Integer, primary_key=True)
    order_no = Column(String(50), unique=True, nullable=False)
    customer_id = Column(Integer, ForeignKey('customers.id'))
    order_date = Column(Date, nullable=False)
    delivery_date = Column(Date, nullable=False)
    status = Column(String(20), default='pending')
    
    # 关系定义
    customer = relationship('Customer', back_populates='orders')
    items = relationship('OrderItem', back_populates='order')
```

#### 6.2.3 业务服务层
```python
# 订单服务示例
class OrderService:
    def __init__(self, db: Session):
        self.db = db
    
    async def create_order(self, order_data: OrderCreate) -> Order:
        # 业务逻辑实现
        pass
    
    async def update_order_status(self, order_id: int, status: str) -> Order:
        # 状态更新逻辑
        pass
    
    async def calculate_delivery_date(self, order: Order) -> date:
        # 交期计算逻辑
        pass
```

## 7. 集成接口设计

### 4.1 微信集成方案

#### 4.1.1 企业微信集成
```python
# 企业微信API封装
class WeChatWorkAPI:
    def __init__(self, corp_id: str, corp_secret: str):
        self.corp_id = corp_id
        self.corp_secret = corp_secret
        self.access_token = None
    
    async def send_message(self, 
                          user_ids: List[str], 
                          message: str, 
                          msg_type: str = "text") -> bool:
        """发送消息到企业微信"""
        pass
    
    async def send_card_message(self, 
                               user_ids: List[str], 
                               card_data: dict) -> bool:
        """发送卡片消息"""
        pass
```

#### 4.1.2 微信小程序集成
- **订单查询小程序**：快速查询订单状态
- **进度更新小程序**：移动端进度更新
- **审批流程小程序**：移动端审批功能

### 4.2 短信邮件集成

#### 4.2.1 短信服务集成
```python
# 短信服务封装
class SMSService:
    def __init__(self, provider: str, config: dict):
        self.provider = provider
        self.config = config
    
    async def send_sms(self, 
                      phone: str, 
                      template_id: str, 
                      params: dict) -> bool:
        """发送短信"""
        pass
    
    async def send_batch_sms(self, 
                            phones: List[str], 
                            template_id: str, 
                            params: dict) -> List[bool]:
        """批量发送短信"""
        pass
```

#### 4.2.2 邮件服务集成
```python
# 邮件服务封装
class EmailService:
    def __init__(self, smtp_config: dict):
        self.smtp_config = smtp_config
    
    async def send_email(self, 
                        to_emails: List[str], 
                        subject: str, 
                        content: str, 
                        attachments: List[str] = None) -> bool:
        """发送邮件"""
        pass
    
    async def send_template_email(self, 
                                 to_emails: List[str], 
                                 template_id: str, 
                                 template_data: dict) -> bool:
        """发送模板邮件"""
        pass
```

### 4.3 Excel文件处理与勤哲Excel服务器兼容性

#### 4.3.1 勤哲Excel服务器兼容性设计

**兼容性原则**：
- 保持与勤哲Excel服务器数据格式的完全兼容
- 支持勤哲Excel服务器的标准工作表结构
- 确保数据交换的无缝对接
- 维护现有ERP系统的数据完整性

```python
# 勤哲Excel服务器兼容处理服务
class QinZheExcelProcessor:
    def __init__(self):
        # 支持勤哲Excel服务器的标准格式
        self.supported_formats = ['.xlsx', '.xls', '.csv']
        # 勤哲Excel服务器标准字段映射
        self.qinzhe_field_mapping = {
            '订单号': 'order_no',
            '客户名称': 'customer_name', 
            '产品编码': 'product_code',
            '产品名称': 'product_name',
            '规格型号': 'specifications',
            '订单数量': 'quantity',
            '单位': 'unit',
            '单价': 'unit_price',
            '金额': 'amount',
            '交货日期': 'delivery_date',
            '订单日期': 'order_date',
            '业务员': 'salesperson',
            '备注': 'remarks'
        }
        # 勤哲Excel服务器数据验证规则
        self.qinzhe_validation_rules = {
            'order_no': {'required': True, 'max_length': 50},
            'customer_name': {'required': True, 'max_length': 100},
            'product_code': {'required': True, 'max_length': 50},
            'quantity': {'required': True, 'type': 'number', 'min': 0},
            'unit_price': {'required': True, 'type': 'decimal', 'min': 0},
            'delivery_date': {'required': True, 'type': 'date'}
        }
    
    async def parse_qinzhe_order_file(self, file_path: str) -> List[dict]:
        """解析勤哲Excel服务器订单文件"""
        import pandas as pd
        
        try:
            # 读取Excel文件，支持勤哲Excel服务器的标准格式
            if file_path.endswith('.xlsx') or file_path.endswith('.xls'):
                df = pd.read_excel(file_path, sheet_name=0)
            elif file_path.endswith('.csv'):
                df = pd.read_csv(file_path, encoding='utf-8-sig')
            
            # 数据清洗和格式化
            df = df.dropna(how='all')  # 删除空行
            df = df.fillna('')  # 填充空值
            
            # 字段映射转换
            orders = []
            for _, row in df.iterrows():
                order_data = {}
                for qinzhe_field, system_field in self.qinzhe_field_mapping.items():
                    if qinzhe_field in row:
                        order_data[system_field] = row[qinzhe_field]
                
                # 数据类型转换
                order_data = self._convert_data_types(order_data)
                orders.append(order_data)
            
            return orders
            
        except Exception as e:
            raise ValueError(f"解析勤哲Excel文件失败: {str(e)}")
    
    async def validate_qinzhe_data(self, orders: List[dict]) -> ValidationResult:
        """验证勤哲Excel服务器数据格式"""
        errors = []
        warnings = []
        
        for i, order in enumerate(orders):
            row_num = i + 2  # Excel行号（从第2行开始）
            
            # 验证必填字段
            for field, rules in self.qinzhe_validation_rules.items():
                if rules.get('required') and not order.get(field):
                    errors.append(f"第{row_num}行：{field}字段不能为空")
                
                # 验证数据类型
                if order.get(field) and rules.get('type'):
                    if not self._validate_data_type(order[field], rules['type']):
                        errors.append(f"第{row_num}行：{field}字段数据类型错误")
                
                # 验证数值范围
                if order.get(field) and rules.get('min') is not None:
                    if float(order[field]) < rules['min']:
                        errors.append(f"第{row_num}行：{field}字段值不能小于{rules['min']}")
        
        return ValidationResult(errors=errors, warnings=warnings)
    
    async def export_qinzhe_report(self, data: List[dict], template_type: str) -> str:
        """导出勤哲Excel服务器兼容格式报表"""
        import pandas as pd
        from datetime import datetime
        
        # 根据模板类型选择字段映射
        if template_type == 'production_plan':
            field_mapping = {
                'order_no': '订单号',
                'product_code': '产品编码',
                'product_name': '产品名称',
                'planned_quantity': '计划数量',
                'planned_start_date': '计划开始日期',
                'planned_end_date': '计划完成日期',
                'production_line': '生产线',
                'status': '状态'
            }
        elif template_type == 'material_requirement':
            field_mapping = {
                'material_code': '物料编码',
                'material_name': '物料名称',
                'required_quantity': '需求数量',
                'stock_quantity': '库存数量',
                'shortage_quantity': '缺料数量',
                'supplier': '供应商',
                'expected_arrival_date': '预计到货日期'
            }
        elif template_type == 'order_progress':
            field_mapping = {
                'order_no': '订单号',
                'customer_name': '客户名称',
                'product_name': '产品名称',
                'order_quantity': '订单数量',
                'completed_quantity': '完成数量',
                'completion_rate': '完成率',
                'delivery_date': '交货日期',
                'status': '订单状态'
            }
        
        # 数据转换
        export_data = []
        for item in data:
            export_item = {}
            for system_field, qinzhe_field in field_mapping.items():
                export_item[qinzhe_field] = item.get(system_field, '')
            export_data.append(export_item)
        
        # 创建DataFrame
        df = pd.DataFrame(export_data)
        
        # 生成文件名
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"勤哲_{template_type}_{timestamp}.xlsx"
        file_path = f"exports/{filename}"
        
        # 导出Excel文件，保持勤哲Excel服务器兼容格式
        with pd.ExcelWriter(file_path, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name='数据', index=False)
            
            # 设置列宽和格式，符合勤哲Excel服务器标准
            worksheet = writer.sheets['数据']
            for column in worksheet.columns:
                max_length = 0
                column_letter = column[0].column_letter
                for cell in column:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(str(cell.value))
                    except:
                        pass
                adjusted_width = min(max_length + 2, 50)
                worksheet.column_dimensions[column_letter].width = adjusted_width
        
        return file_path
    
    def _convert_data_types(self, order_data: dict) -> dict:
        """转换数据类型以符合勤哲Excel服务器格式"""
        # 数量字段转换为整数
        if 'quantity' in order_data and order_data['quantity']:
            try:
                order_data['quantity'] = int(float(order_data['quantity']))
            except:
                pass
        
        # 价格字段转换为浮点数
        if 'unit_price' in order_data and order_data['unit_price']:
            try:
                order_data['unit_price'] = float(order_data['unit_price'])
            except:
                pass
        
        # 日期字段格式化
        date_fields = ['delivery_date', 'order_date']
        for field in date_fields:
            if field in order_data and order_data[field]:
                try:
                    if isinstance(order_data[field], str):
                        from datetime import datetime
                        order_data[field] = datetime.strptime(order_data[field], '%Y-%m-%d').date()
                except:
                    pass
        
        return order_data
    
    def _validate_data_type(self, value, expected_type: str) -> bool:
        """验证数据类型"""
        try:
            if expected_type == 'number':
                float(value)
                return True
            elif expected_type == 'decimal':
                float(value)
                return True
            elif expected_type == 'date':
                from datetime import datetime
                if isinstance(value, str):
                    datetime.strptime(value, '%Y-%m-%d')
                return True
            return True
        except:
            return False

# 勤哲Excel服务器数据同步服务
class QinZheDataSyncService:
    def __init__(self):
        self.sync_config = {
            'orders_table': '订单表',
            'products_table': '产品表',
            'customers_table': '客户表',
            'materials_table': '物料表'
        }
    
    async def sync_to_qinzhe(self, data_type: str, data: List[dict]) -> bool:
        """同步数据到勤哲Excel服务器"""
        try:
            # 根据数据类型选择对应的勤哲表格
            table_name = self.sync_config.get(f"{data_type}_table")
            if not table_name:
                raise ValueError(f"不支持的数据类型: {data_type}")
            
            # 生成勤哲Excel服务器兼容的数据文件
            processor = QinZheExcelProcessor()
            file_path = await processor.export_qinzhe_report(data, data_type)
            
            # 这里可以集成勤哲Excel服务器的API或文件接口
            # 实现数据的自动导入
            
            return True
        except Exception as e:
            logger.error(f"同步数据到勤哲Excel服务器失败: {str(e)}")
            return False
    
    async def sync_from_qinzhe(self, data_type: str) -> List[dict]:
        """从勤哲Excel服务器同步数据"""
        try:
            # 这里可以集成勤哲Excel服务器的数据导出接口
            # 获取最新的数据文件
            
            # 解析勤哲Excel服务器导出的数据
            processor = QinZheExcelProcessor()
            # file_path = await self._get_qinzhe_export_file(data_type)
            # data = await processor.parse_qinzhe_order_file(file_path)
            
            return []
        except Exception as e:
            logger.error(f"从勤哲Excel服务器同步数据失败: {str(e)}")
            return []

# 验证结果类
class ValidationResult:
    def __init__(self, errors: List[str] = None, warnings: List[str] = None):
        self.errors = errors or []
        self.warnings = warnings or []
        self.is_valid = len(self.errors) == 0
```

#### 4.3.2 Excel模板管理

```python
# Excel模板管理服务
class ExcelTemplateManager:
    def __init__(self):
        self.template_path = "templates/excel/"
        # 勤哲Excel服务器标准模板
        self.qinzhe_templates = {
            'order_import': '勤哲订单导入模板.xlsx',
            'production_plan': '勤哲生产计划模板.xlsx',
            'material_requirement': '勤哲物料需求模板.xlsx',
            'inventory_report': '勤哲库存报表模板.xlsx',
            'order_progress': '勤哲订单进度模板.xlsx'
        }
    
    async def get_template(self, template_type: str) -> str:
        """获取勤哲Excel服务器兼容模板"""
        template_file = self.qinzhe_templates.get(template_type)
        if not template_file:
            raise ValueError(f"不支持的模板类型: {template_type}")
        
        return os.path.join(self.template_path, template_file)
    
    async def create_template_with_data(self, template_type: str, data: List[dict]) -> str:
        """基于模板创建包含数据的Excel文件"""
        template_path = await self.get_template(template_type)
        
        # 使用openpyxl处理模板
        from openpyxl import load_workbook
        import pandas as pd
        
        # 加载模板
        workbook = load_workbook(template_path)
        worksheet = workbook.active
        
        # 填充数据（从第2行开始，第1行为标题）
        for row_idx, item in enumerate(data, start=2):
            col_idx = 1
            for key, value in item.items():
                worksheet.cell(row=row_idx, column=col_idx, value=value)
                col_idx += 1
        
        # 保存文件
        from datetime import datetime
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        output_file = f"勤哲_{template_type}_{timestamp}.xlsx"
        output_path = f"exports/{output_file}"
        
        workbook.save(output_path)
        return output_path
```

## 8. 实施方案

### 5.1 开发环境搭建

#### 5.1.1 前端开发环境
```bash
# 创建React项目
npx create-react-app pmc-frontend --template typescript
cd pmc-frontend

# 安装依赖
npm install antd @ant-design/pro-components
npm install echarts echarts-for-react
npm install @reduxjs/toolkit react-redux
npm install react-router-dom
npm install axios

# 开发工具
npm install -D eslint prettier husky
npm install -D @types/node @types/react @types/react-dom
```

#### 5.1.2 后端开发环境
```bash
# 创建Python虚拟环境
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# 安装依赖
pip install fastapi[all]
pip install sqlalchemy[postgresql] alembic
pip install celery[redis]
pip install pandas openpyxl
pip install python-multipart
pip install loguru
```

### 5.2 数据库初始化

#### 5.2.1 PostgreSQL配置
```sql
-- 创建数据库
CREATE DATABASE pmc_system;
CREATE USER pmc_user WITH PASSWORD 'pmc_password';
GRANT ALL PRIVILEGES ON DATABASE pmc_system TO pmc_user;

-- 创建扩展
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";
```

#### 5.2.2 数据库迁移
```bash
# 初始化Alembic
alembic init alembic

# 创建迁移文件
alembic revision --autogenerate -m "Initial migration"

# 执行迁移
alembic upgrade head
```

### 5.3 部署方案

#### 5.3.1 Docker容器化
```dockerfile
# 前端Dockerfile
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

```dockerfile
# 后端Dockerfile
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 8000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

#### 5.3.2 Docker Compose配置
```yaml
version: '3.8'
services:
  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend
  
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://pmc_user:pmc_password@db:5432/pmc_system
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis
  
  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=pmc_system
      - POSTGRES_USER=pmc_user
      - POSTGRES_PASSWORD=pmc_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
  
  celery:
    build: ./backend
    command: celery -A app.celery worker --loglevel=info
    environment:
      - DATABASE_URL=postgresql://pmc_user:pmc_password@db:5432/pmc_system
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis

volumes:
  postgres_data:
  redis_data:
```

## 9. 性能优化方案

### 6.1 前端性能优化

#### 6.1.1 代码分割与懒加载
```typescript
// 路由懒加载
const OrderManagement = lazy(() => import('./pages/OrderManagement'));
const ProductionMonitor = lazy(() => import('./pages/ProductionMonitor'));
const MaterialControl = lazy(() => import('./pages/MaterialControl'));

// 组件懒加载
const LazyChart = lazy(() => import('./components/Chart'));
```

#### 6.1.2 数据缓存策略
```typescript
// React Query缓存配置
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5分钟
      cacheTime: 10 * 60 * 1000, // 10分钟
      refetchOnWindowFocus: false,
    },
  },
});

// 本地存储缓存
class CacheManager {
  static setCache(key: string, data: any, ttl: number = 300000) {
    const item = {
      data,
      timestamp: Date.now(),
      ttl
    };
    localStorage.setItem(key, JSON.stringify(item));
  }
  
  static getCache(key: string) {
    const item = localStorage.getItem(key);
    if (!item) return null;
    
    const parsed = JSON.parse(item);
    if (Date.now() - parsed.timestamp > parsed.ttl) {
      localStorage.removeItem(key);
      return null;
    }
    
    return parsed.data;
  }
}
```

### 6.2 后端性能优化

#### 6.2.1 数据库优化
```sql
-- 索引优化
CREATE INDEX CONCURRENTLY idx_orders_status_date 
ON orders(status, created_at) 
WHERE status IN ('pending', 'in_progress');

CREATE INDEX CONCURRENTLY idx_materials_warehouse_code 
ON materials(warehouse_id, material_code);

-- 分区表设计
CREATE TABLE order_history (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    order_id UUID NOT NULL,
    status VARCHAR(50) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
) PARTITION BY RANGE (created_at);

-- 创建月度分区
CREATE TABLE order_history_2024_01 PARTITION OF order_history
FOR VALUES FROM ('2025-07-01') TO ('2025-08-01');
```

#### 6.2.2 缓存策略
```python
# Redis缓存装饰器
from functools import wraps
import redis
import json

redis_client = redis.Redis(host='localhost', port=6379, db=0)

def cache_result(ttl: int = 300):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # 生成缓存键
            cache_key = f"{func.__name__}:{hash(str(args) + str(kwargs))}"
            
            # 尝试从缓存获取
            cached = redis_client.get(cache_key)
            if cached:
                return json.loads(cached)
            
            # 执行函数并缓存结果
            result = await func(*args, **kwargs)
            redis_client.setex(cache_key, ttl, json.dumps(result, default=str))
            
            return result
        return wrapper
    return decorator

# 使用示例
@cache_result(ttl=600)
async def get_production_summary(date_range: str):
    # 复杂的数据聚合查询
    pass
```

### 6.3 实时数据处理

#### 6.3.1 WebSocket实时推送
```python
# WebSocket管理器
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []
        self.user_connections: Dict[str, List[WebSocket]] = {}
    
    async def connect(self, websocket: WebSocket, user_id: str):
        await websocket.accept()
        self.active_connections.append(websocket)
        
        if user_id not in self.user_connections:
            self.user_connections[user_id] = []
        self.user_connections[user_id].append(websocket)
    
    async def broadcast_to_user(self, user_id: str, message: dict):
        if user_id in self.user_connections:
            for connection in self.user_connections[user_id]:
                try:
                    await connection.send_json(message)
                except:
                    await self.disconnect(connection, user_id)

manager = ConnectionManager()

@app.websocket("/ws/{user_id}")
async def websocket_endpoint(websocket: WebSocket, user_id: str):
    await manager.connect(websocket, user_id)
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        await manager.disconnect(websocket, user_id)
```

## 10. 安全设计方案

### 7.1 身份认证与授权

#### 7.1.1 JWT认证实现
```python
# JWT认证服务
class AuthService:
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.algorithm = "HS256"
    
    def create_access_token(self, data: dict, expires_delta: timedelta = None):
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=15)
        
        to_encode.update({"exp": expire})
        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
        return encoded_jwt
    
    def verify_token(self, token: str):
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except JWTError:
            return None

# 权限装饰器
def require_permission(permission: str):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # 从请求中获取用户信息
            current_user = get_current_user()
            
            # 检查权限
            if not has_permission(current_user, permission):
                raise HTTPException(status_code=403, detail="权限不足")
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator
```

#### 7.1.2 RBAC权限模型
```python
# 权限模型
class Permission(Base):
    __tablename__ = "permissions"
    
    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    name = Column(String(100), unique=True, nullable=False)
    description = Column(String(255))
    resource = Column(String(100), nullable=False)  # 资源类型
    action = Column(String(50), nullable=False)     # 操作类型

class Role(Base):
    __tablename__ = "roles"
    
    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    name = Column(String(100), unique=True, nullable=False)
    description = Column(String(255))
    permissions = relationship("Permission", secondary="role_permissions")

class User(Base):
    __tablename__ = "users"
    
    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    username = Column(String(100), unique=True, nullable=False)
    email = Column(String(255), unique=True, nullable=False)
    password_hash = Column(String(255), nullable=False)
    roles = relationship("Role", secondary="user_roles")
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
```

### 7.2 数据安全

#### 7.2.1 数据加密
```python
# 敏感数据加密
from cryptography.fernet import Fernet

class DataEncryption:
    def __init__(self, key: bytes = None):
        self.key = key or Fernet.generate_key()
        self.cipher = Fernet(self.key)
    
    def encrypt(self, data: str) -> str:
        """加密数据"""
        return self.cipher.encrypt(data.encode()).decode()
    
    def decrypt(self, encrypted_data: str) -> str:
        """解密数据"""
        return self.cipher.decrypt(encrypted_data.encode()).decode()

# 数据库字段加密
class EncryptedField(TypeDecorator):
    impl = String
    
    def __init__(self, encryption_service: DataEncryption, *args, **kwargs):
        self.encryption_service = encryption_service
        super().__init__(*args, **kwargs)
    
    def process_bind_param(self, value, dialect):
        if value is not None:
            return self.encryption_service.encrypt(value)
        return value
    
    def process_result_value(self, value, dialect):
        if value is not None:
            return self.encryption_service.decrypt(value)
        return value
```

#### 7.2.2 审计日志
```python
# 审计日志模型
class AuditLog(Base):
    __tablename__ = "audit_logs"
    
    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID, ForeignKey("users.id"))
    action = Column(String(100), nullable=False)
    resource_type = Column(String(100), nullable=False)
    resource_id = Column(String(255))
    old_values = Column(JSON)
    new_values = Column(JSON)
    ip_address = Column(String(45))
    user_agent = Column(String(500))
    timestamp = Column(DateTime, default=datetime.utcnow)

# 审计装饰器
def audit_action(action: str, resource_type: str):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # 执行原函数
            result = await func(*args, **kwargs)
            
            # 记录审计日志
            await log_audit(
                user_id=get_current_user_id(),
                action=action,
                resource_type=resource_type,
                resource_id=str(result.id) if hasattr(result, 'id') else None,
                new_values=result.dict() if hasattr(result, 'dict') else None
            )
            
            return result
        return wrapper
    return decorator
```

## 11. 项目管理与质量保证

### 8.1 开发流程规范

#### 8.1.1 Git工作流
```bash
# 分支策略
main          # 主分支，生产环境代码
develop       # 开发分支，集成测试
feature/*     # 功能分支
hotfix/*      # 热修复分支
release/*     # 发布分支

# 提交规范
git commit -m "feat(order): 添加订单状态更新功能"
git commit -m "fix(material): 修复库存计算错误"
git commit -m "docs(api): 更新API文档"
git commit -m "test(unit): 添加订单服务单元测试"
```

#### 8.1.2 代码质量检查
```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v3
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-cov black flake8
    
    - name: Code formatting check
      run: black --check .
    
    - name: Linting
      run: flake8 .
    
    - name: Run tests
      run: pytest --cov=app tests/
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
```

### 8.2 测试策略

#### 8.2.1 单元测试
```python
# 测试示例
import pytest
from app.services.order_service import OrderService
from app.models.order import Order

class TestOrderService:
    @pytest.fixture
    def order_service(self):
        return OrderService()
    
    @pytest.fixture
    def sample_order(self):
        return Order(
            order_number="ORD-001",
            customer_name="测试客户",
            product_code="PRD-001",
            quantity=100,
            delivery_date="2025-08-01"
        )
    
    async def test_create_order(self, order_service, sample_order):
        """测试创建订单"""
        result = await order_service.create_order(sample_order)
        
        assert result.id is not None
        assert result.status == "pending"
        assert result.order_number == "ORD-001"
    
    async def test_update_order_status(self, order_service, sample_order):
        """测试更新订单状态"""
        # 创建订单
        order = await order_service.create_order(sample_order)
        
        # 更新状态
        updated_order = await order_service.update_status(order.id, "in_progress")
        
        assert updated_order.status == "in_progress"
```

#### 8.2.2 集成测试
```python
# API集成测试
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_order_workflow():
    """测试订单完整流程"""
    # 1. 创建订单
    order_data = {
        "order_number": "ORD-TEST-001",
        "customer_name": "测试客户",
        "product_code": "PRD-001",
        "quantity": 100,
        "delivery_date": "2025-08-01"
    }
    
    response = client.post("/api/orders", json=order_data)
    assert response.status_code == 201
    order_id = response.json()["id"]
    
    # 2. 查询订单
    response = client.get(f"/api/orders/{order_id}")
    assert response.status_code == 200
    assert response.json()["status"] == "pending"
    
    # 3. 更新订单状态
    response = client.patch(f"/api/orders/{order_id}/status", 
                           json={"status": "in_progress"})
    assert response.status_code == 200
    assert response.json()["status"] == "in_progress"
```

### 8.3 监控与运维

#### 8.3.1 应用监控
```python
# 性能监控
from prometheus_client import Counter, Histogram, generate_latest

# 指标定义
REQUEST_COUNT = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint'])
REQUEST_DURATION = Histogram('http_request_duration_seconds', 'HTTP request duration')
ERROR_COUNT = Counter('http_errors_total', 'Total HTTP errors', ['status_code'])

# 中间件
@app.middleware("http")
async def monitor_requests(request: Request, call_next):
    start_time = time.time()
    
    response = await call_next(request)
    
    # 记录指标
    REQUEST_COUNT.labels(method=request.method, endpoint=request.url.path).inc()
    REQUEST_DURATION.observe(time.time() - start_time)
    
    if response.status_code >= 400:
        ERROR_COUNT.labels(status_code=response.status_code).inc()
    
    return response

# 健康检查端点
@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "version": "1.0.0"
    }

# 指标端点
@app.get("/metrics")
async def metrics():
    return Response(generate_latest(), media_type="text/plain")
```

#### 8.3.2 日志管理
```python
# 结构化日志配置
from loguru import logger
import sys

# 日志配置
logger.remove()
logger.add(
    sys.stdout,
    format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {name}:{function}:{line} | {message}",
    level="INFO",
    serialize=True
)

logger.add(
    "logs/app_{time:YYYY-MM-DD}.log",
    rotation="1 day",
    retention="30 days",
    compression="zip",
    format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {name}:{function}:{line} | {message}",
    level="DEBUG"
)

# 业务日志记录
class BusinessLogger:
    @staticmethod
    def log_order_created(order_id: str, user_id: str):
        logger.info("订单创建", extra={
            "event": "order_created",
            "order_id": order_id,
            "user_id": user_id,
            "timestamp": datetime.utcnow().isoformat()
        })
    
    @staticmethod
    def log_production_started(order_id: str, production_line: str):
        logger.info("生产开始", extra={
            "event": "production_started",
            "order_id": order_id,
            "production_line": production_line,
            "timestamp": datetime.utcnow().isoformat()
        })
```

## 12. 技术可行性分析

### 9.1 前端技术可行性

#### 9.1.1 技术栈成熟度
- **React 18**：成熟的前端框架，具有良好的生态系统和社区支持
- **TypeScript**：提供类型安全，提高代码质量和开发效率
- **Ant Design Pro**：企业级UI组件库，快速构建管理界面
- **ECharts**：强大的图表库，支持复杂的数据可视化需求

#### 9.1.2 性能表现
- **虚拟DOM**：React的虚拟DOM机制保证了高效的页面渲染
- **代码分割**：支持按需加载，减少初始加载时间
- **缓存策略**：React Query提供强大的数据缓存能力

### 9.2 后端技术可行性

#### 9.2.1 框架选择
- **FastAPI**：高性能异步Web框架，自动生成API文档
- **SQLAlchemy**：成熟的ORM框架，支持复杂查询和事务
- **PostgreSQL**：企业级关系数据库，支持复杂事务和并发
- **Celery**：分布式任务队列，支持异步处理和定时任务

#### 9.2.2 扩展性保证
- **微服务架构**：支持水平扩展和服务解耦
- **容器化部署**：Docker容器化保证环境一致性
- **负载均衡**：支持多实例部署和负载分发

### 9.3 集成技术可行性

#### 9.3.1 第三方服务集成
- **企业微信API**：官方支持，文档完善，稳定可靠
- **短信/邮件服务**：多家服务商支持，技术成熟
- **Excel处理**：Python生态丰富，处理能力强

#### 9.3.2 数据处理能力
- **大文件处理**：支持流式处理，避免内存溢出
- **并发处理**：异步处理机制支持高并发场景
- **错误恢复**：完善的错误处理和重试机制

## 13. 分阶段实施计划

### 10.1 第一阶段：基础平台搭建（4周）

#### Week 1：Docker容器化环境搭建
- **Docker环境配置**：
  - 多环境容器配置（开发/生产/监控）
  - 健康检查机制配置
  - 数据卷和网络配置
  - 容器启动脚本编写
- **依赖环境验证**：
  - Python 3.12 + Flask 3.0 环境测试
  - 已配置依赖包验证（Pandas、Loguru等）
  - 容器间通信测试
  - 日志收集和监控配置

#### Week 2：数据库与架构设计
- 数据库设计与初始化
- 基础架构代码框架
- API接口规范定义
- 容器化CI/CD流水线搭建

#### Week 3-4：用户系统与权限管理
- 用户认证系统（JWT）
- RBAC权限管理模型
- 基础API接口开发
- 前端路由和布局框架

### 10.2 第二阶段：核心功能开发（8周）

#### Week 5-6：订单管理模块
- 订单数据模型设计
- 订单CRUD操作API
- 订单看板界面开发
- 订单状态流转逻辑

#### Week 7-8：生产计划模块
- 生产计划算法实现
- 甘特图组件开发
- 资源分配界面
- 计划调整功能

#### Week 9-10：物料管理模块
- BOM管理功能
- 库存管理系统
- 采购需求计算
- 库存可视化界面

#### Week 11-12：进度跟踪模块
- 生产进度监控
- 异常预警系统
- 状态监控看板
- 报表生成功能

### 10.3 第三阶段：集成与优化（6周）

#### Week 13-14：通信集成
- 企业微信API集成
- 短信服务集成
- 邮件服务集成
- 消息模板管理

#### Week 15-16：数据处理
- Excel导入导出功能
- 数据验证与清洗
- 批量数据处理
- 报表模板设计

#### Week 17-18：性能与安全
- 性能优化调优
- 安全加固措施
- 数据备份策略
- 监控告警系统

### 10.4 第四阶段：测试与部署（4周）

#### Week 19-20：测试阶段
- 单元测试编写
- 集成测试执行
- 性能测试验证
- 安全测试检查

#### Week 21-22：部署上线
- 生产环境部署
- 用户验收测试
- 培训文档编写
- 正式上线运行

## 14. 风险评估与应对策略

### 11.1 技术风险

#### 11.1.1 第三方API稳定性
- **风险描述**：企业微信、短信、邮件服务API可能出现不稳定
- **影响程度**：中等
- **应对策略**：
  - 实现多渠道备份机制
  - 设计降级处理方案
  - 建立API监控和自动切换
  - 缓存重要通知，支持重发

#### 11.1.2 性能瓶颈
- **风险描述**：大数据量处理可能导致性能问题
- **影响程度**：高
- **应对策略**：
  - 数据分页和懒加载
  - Redis缓存机制
  - 数据库索引优化
  - 异步处理队列

### 11.2 数据风险

#### 11.2.1 数据安全
- **风险描述**：敏感数据泄露或被恶意访问
- **影响程度**：高
- **应对策略**：
  - 数据加密存储
  - 访问权限控制
  - 审计日志记录
  - 定期安全检查

#### 11.2.2 数据一致性
- **风险描述**：并发操作可能导致数据不一致
- **影响程度**：中等
- **应对策略**：
  - 数据库事务控制
  - 乐观锁机制
  - 数据校验规则
  - 定期数据检查

### 11.3 集成风险

#### 11.3.1 现有系统兼容性
- **风险描述**：与现有ERP系统集成可能存在兼容性问题
- **影响程度**：中等
- **应对策略**：
  - 渐进式集成方案
  - 充分的集成测试
  - 数据格式转换
  - 回滚机制设计

#### 11.3.2 用户接受度
- **风险描述**：用户可能对新系统接受度不高
- **影响程度**：中等
- **应对策略**：
  - 用户培训计划
  - 分阶段推广
  - 用户反馈收集
  - 界面优化改进

### 11.4 项目管理风险

#### 11.4.1 进度延期
- **风险描述**：开发进度可能因各种原因延期
- **影响程度**：中等
- **应对策略**：
  - 合理的时间缓冲
  - 里程碑监控
  - 资源动态调配
  - 范围管理控制

#### 11.4.2 需求变更
- **风险描述**：用户需求可能在开发过程中发生变更
- **影响程度**：中等
- **应对策略**：
  - 需求变更控制流程
  - 影响评估机制
  - 版本管理策略
  - 敏捷开发方法

## 15. 总结

### 12.1 技术方案优势

1. **技术先进性**：采用现代化的技术栈，保证系统的先进性和可维护性
2. **容器化优势**：基于Docker的容器化部署，确保环境一致性和快速部署
3. **多环境支持**：开发、生产、监控环境隔离，支持并行开发和测试
4. **架构合理性**：模块化设计，支持系统的扩展和维护
5. **用户体验**：图形化界面设计，提供良好的用户交互体验
6. **集成能力**：强大的第三方集成能力，支持多渠道通信
7. **安全可靠**：完善的安全机制和监控体系
8. **运维便捷**：容器化管理、健康检查、日志收集一体化

### 12.2 预期效果

1. **效率提升**：通过自动化和可视化，显著提升PMC工作效率
2. **成本降低**：减少人工操作，降低运营成本
3. **质量改善**：通过系统化管理，提高生产质量
4. **响应速度**：实时监控和预警，快速响应异常情况
5. **决策支持**：数据分析和报表，为管理决策提供支持

### 12.3 后续发展

1. **AI智能化**：逐步引入机器学习算法，提升系统智能化水平
2. **移动化扩展**：开发移动端应用，支持移动办公
3. **IoT集成**：与物联网设备集成，实现更精细的生产监控
4. **大数据分析**：构建数据仓库，进行深度数据分析
5. **云原生架构**：向云原生架构演进，提升系统弹性和可扩展性

本技术方案为PMC全流程图表界面应用提供了完整的技术实现路径，通过分阶段实施和风险控制，确保项目的成功交付和长期稳定运行。