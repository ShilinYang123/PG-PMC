# 代码质量自动化工具链

## 概述

本文档为3AI项目建立完整的代码质量自动化工具链，涵盖代码质量检测、自动化测试、持续集成、代码审查、质量门禁等全流程自动化体系。

## 1. 代码质量检测体系

### 1.1 静态代码分析

```typescript
// ESLint配置 - .eslintrc.js
module.exports = {
  extends: [
    '@typescript-eslint/recommended',
    'plugin:@typescript-eslint/recommended-requiring-type-checking',
    'plugin:security/recommended',
    'plugin:sonarjs/recommended',
    'plugin:import/recommended',
    'plugin:import/typescript'
  ],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 2022,
    sourceType: 'module',
    project: './tsconfig.json'
  },
  plugins: [
    '@typescript-eslint',
    'security',
    'sonarjs',
    'import',
    'jsdoc',
    'prefer-arrow'
  ],
  rules: {
    // 代码质量规则
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'error',
    '@typescript-eslint/explicit-function-return-type': 'warn',
    '@typescript-eslint/no-floating-promises': 'error',
    '@typescript-eslint/await-thenable': 'error',
    
    // 安全规则
    'security/detect-object-injection': 'error',
    'security/detect-non-literal-regexp': 'error',
    'security/detect-unsafe-regex': 'error',
    
    // 复杂度控制
    'sonarjs/cognitive-complexity': ['error', 15],
    'sonarjs/no-duplicate-string': ['error', 3],
    'complexity': ['error', 10],
    'max-depth': ['error', 4],
    'max-lines-per-function': ['error', 50],
    
    // 导入规则
    'import/no-unresolved': 'error',
    'import/no-cycle': 'error',
    'import/order': ['error', {
      'groups': ['builtin', 'external', 'internal', 'parent', 'sibling', 'index'],
      'newlines-between': 'always'
    }],
    
    // 文档规则
    'jsdoc/require-description': 'warn',
    'jsdoc/require-param-description': 'warn',
    'jsdoc/require-returns-description': 'warn'
  },
  overrides: [
    {
      files: ['*.test.ts', '*.spec.ts'],
      rules: {
        '@typescript-eslint/no-explicit-any': 'off',
        'sonarjs/no-duplicate-string': 'off'
      }
    }
  ]
};
```

### 1.2 代码质量分析器

```typescript
class CodeQualityAnalyzer {
  private eslint: ESLint;
  private sonarScanner: SonarScanner;
  private complexityAnalyzer: ComplexityAnalyzer;
  private duplicateDetector: DuplicateDetector;
  private securityScanner: SecurityScanner;

  constructor() {
    this.eslint = new ESLint({
      configFile: '.eslintrc.js',
      fix: true
    });
    this.sonarScanner = new SonarScanner();
    this.complexityAnalyzer = new ComplexityAnalyzer();
    this.duplicateDetector = new DuplicateDetector();
    this.securityScanner = new SecurityScanner();
  }

  async analyzeProject(projectPath: string): Promise<QualityReport> {
    const report: QualityReport = {
      timestamp: new Date(),
      projectPath,
      summary: {
        totalFiles: 0,
        linesOfCode: 0,
        technicalDebt: 0,
        maintainabilityIndex: 0,
        testCoverage: 0
      },
      issues: [],
      metrics: {},
      recommendations: []
    };

    // 1. ESLint分析
    const eslintResults = await this.runESLintAnalysis(projectPath);
    report.issues.push(...this.processESLintResults(eslintResults));

    // 2. 复杂度分析
    const complexityResults = await this.complexityAnalyzer.analyze(projectPath);
    report.metrics.complexity = complexityResults;

    // 3. 重复代码检测
    const duplicateResults = await this.duplicateDetector.detect(projectPath);
    report.metrics.duplication = duplicateResults;

    // 4. 安全漏洞扫描
    const securityResults = await this.securityScanner.scan(projectPath);
    report.issues.push(...this.processSecurityResults(securityResults));

    // 5. SonarQube分析
    const sonarResults = await this.sonarScanner.analyze(projectPath);
    report.metrics.sonar = sonarResults;

    // 6. 生成建议
    report.recommendations = await this.generateRecommendations(report);

    // 7. 计算质量评分
    report.summary = await this.calculateQualityMetrics(report);

    return report;
  }

  private async runESLintAnalysis(projectPath: string): Promise<ESLint.LintResult[]> {
    const filesToLint = await this.eslint.lintFiles(`${projectPath}/**/*.{ts,js}`);
    
    // 自动修复可修复的问题
    await ESLint.outputFixes(filesToLint);
    
    return filesToLint;
  }

  private processESLintResults(results: ESLint.LintResult[]): QualityIssue[] {
    const issues: QualityIssue[] = [];

    for (const result of results) {
      for (const message of result.messages) {
        issues.push({
          type: 'ESLINT',
          severity: this.mapESLintSeverity(message.severity),
          rule: message.ruleId || 'unknown',
          message: message.message,
          file: result.filePath,
          line: message.line,
          column: message.column,
          fixable: message.fix !== undefined
        });
      }
    }

    return issues;
  }

  private async generateRecommendations(report: QualityReport): Promise<QualityRecommendation[]> {
    const recommendations: QualityRecommendation[] = [];

    // 基于复杂度的建议
    if (report.metrics.complexity?.averageComplexity > 10) {
      recommendations.push({
        type: 'COMPLEXITY',
        priority: 'HIGH',
        title: '降低代码复杂度',
        description: '平均复杂度过高，建议重构复杂函数',
        actions: [
          '识别复杂度超过15的函数',
          '应用单一职责原则拆分函数',
          '使用策略模式简化条件逻辑',
          '提取公共逻辑到工具函数'
        ],
        estimatedEffort: '2-3天'
      });
    }

    // 基于重复代码的建议
    if (report.metrics.duplication?.percentage > 5) {
      recommendations.push({
        type: 'DUPLICATION',
        priority: 'MEDIUM',
        title: '消除重复代码',
        description: '重复代码比例过高，影响维护性',
        actions: [
          '识别重复代码块',
          '提取公共函数或类',
          '使用继承或组合模式',
          '建立代码复用库'
        ],
        estimatedEffort: '1-2天'
      });
    }

    // 基于测试覆盖率的建议
    if (report.summary.testCoverage < 80) {
      recommendations.push({
        type: 'TESTING',
        priority: 'HIGH',
        title: '提升测试覆盖率',
        description: '测试覆盖率不足，存在质量风险',
        actions: [
          '为核心业务逻辑添加单元测试',
          '增加集成测试覆盖',
          '实施测试驱动开发(TDD)',
          '配置测试覆盖率门禁'
        ],
        estimatedEffort: '3-5天'
      });
    }

    return recommendations;
  }
}
```

### 1.3 代码度量收集器

```typescript
class CodeMetricsCollector {
  private metricsDatabase: MetricsDatabase;
  private trendAnalyzer: TrendAnalyzer;

  constructor() {
    this.metricsDatabase = new MetricsDatabase();
    this.trendAnalyzer = new TrendAnalyzer();
  }

  async collectMetrics(projectPath: string): Promise<CodeMetrics> {
    const metrics: CodeMetrics = {
      timestamp: new Date(),
      project: path.basename(projectPath),
      
      // 基础度量
      linesOfCode: await this.countLinesOfCode(projectPath),
      numberOfFiles: await this.countFiles(projectPath),
      numberOfClasses: await this.countClasses(projectPath),
      numberOfFunctions: await this.countFunctions(projectPath),
      
      // 复杂度度量
      cyclomaticComplexity: await this.calculateCyclomaticComplexity(projectPath),
      cognitiveComplexity: await this.calculateCognitiveComplexity(projectPath),
      
      // 质量度量
      maintainabilityIndex: await this.calculateMaintainabilityIndex(projectPath),
      technicalDebt: await this.calculateTechnicalDebt(projectPath),
      codeSmells: await this.detectCodeSmells(projectPath),
      
      // 测试度量
      testCoverage: await this.calculateTestCoverage(projectPath),
      testCount: await this.countTests(projectPath),
      
      // 依赖度量
      dependencyCount: await this.countDependencies(projectPath),
      circularDependencies: await this.detectCircularDependencies(projectPath),
      
      // 文档度量
      documentationCoverage: await this.calculateDocumentationCoverage(projectPath)
    };

    // 存储度量数据
    await this.metricsDatabase.store(metrics);
    
    // 分析趋势
    const trends = await this.trendAnalyzer.analyze(metrics);
    
    return { ...metrics, trends };
  }

  private async calculateMaintainabilityIndex(projectPath: string): Promise<number> {
    // 使用Halstead复杂度、圈复杂度、代码行数计算可维护性指数
    const halsteadVolume = await this.calculateHalsteadVolume(projectPath);
    const cyclomaticComplexity = await this.calculateCyclomaticComplexity(projectPath);
    const linesOfCode = await this.countLinesOfCode(projectPath);
    
    // 可维护性指数公式
    const maintainabilityIndex = Math.max(0, 
      (171 - 5.2 * Math.log(halsteadVolume) - 0.23 * cyclomaticComplexity - 16.2 * Math.log(linesOfCode)) * 100 / 171
    );
    
    return Math.round(maintainabilityIndex * 100) / 100;
  }

  private async calculateTechnicalDebt(projectPath: string): Promise<TechnicalDebt> {
    const issues = await this.detectQualityIssues(projectPath);
    
    let totalDebtMinutes = 0;
    const debtByCategory: Record<string, number> = {};
    
    for (const issue of issues) {
      const debtMinutes = this.calculateIssueDebt(issue);
      totalDebtMinutes += debtMinutes;
      
      if (!debtByCategory[issue.category]) {
        debtByCategory[issue.category] = 0;
      }
      debtByCategory[issue.category] += debtMinutes;
    }
    
    return {
      totalMinutes: totalDebtMinutes,
      totalHours: Math.round(totalDebtMinutes / 60 * 100) / 100,
      totalDays: Math.round(totalDebtMinutes / (60 * 8) * 100) / 100,
      byCategory: debtByCategory,
      rating: this.calculateDebtRating(totalDebtMinutes)
    };
  }

  private calculateIssueDebt(issue: QualityIssue): number {
    // 根据问题类型和严重程度计算技术债务时间
    const baseMinutes = {
      'BLOCKER': 60,
      'CRITICAL': 30,
      'MAJOR': 15,
      'MINOR': 5,
      'INFO': 2
    };
    
    const categoryMultiplier = {
      'BUG': 2.0,
      'VULNERABILITY': 3.0,
      'CODE_SMELL': 1.0,
      'DUPLICATION': 0.5
    };
    
    const base = baseMinutes[issue.severity] || 5;
    const multiplier = categoryMultiplier[issue.category] || 1.0;
    
    return Math.round(base * multiplier);
  }
}
```

## 2. 自动化测试体系

### 2.1 测试金字塔实现

```typescript
// Jest配置 - jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: [
    '**/__tests__/**/*.+(ts|tsx|js)',
    '**/*.(test|spec).+(ts|tsx|js)'
  ],
  transform: {
    '^.+\\.(ts|tsx)$': 'ts-jest'
  },
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.test.{ts,tsx}',
    '!src/**/index.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
  testTimeout: 10000,
  maxWorkers: '50%',
  
  // 测试分类
  projects: [
    {
      displayName: 'unit',
      testMatch: ['<rootDir>/src/**/*.test.ts'],
      testEnvironment: 'node'
    },
    {
      displayName: 'integration',
      testMatch: ['<rootDir>/tests/integration/**/*.test.ts'],
      testEnvironment: 'node',
      setupFilesAfterEnv: ['<rootDir>/tests/integration/setup.ts']
    },
    {
      displayName: 'e2e',
      testMatch: ['<rootDir>/tests/e2e/**/*.test.ts'],
      testEnvironment: 'node',
      setupFilesAfterEnv: ['<rootDir>/tests/e2e/setup.ts']
    }
  ]
};
```

### 2.2 智能测试生成器

```typescript
class IntelligentTestGenerator {
  private astAnalyzer: ASTAnalyzer;
  private templateEngine: TestTemplateEngine;
  private mockGenerator: MockGenerator;
  private coverageAnalyzer: CoverageAnalyzer;

  constructor() {
    this.astAnalyzer = new ASTAnalyzer();
    this.templateEngine = new TestTemplateEngine();
    this.mockGenerator = new MockGenerator();
    this.coverageAnalyzer = new CoverageAnalyzer();
  }

  async generateTests(filePath: string): Promise<GeneratedTest[]> {
    // 1. 分析源代码
    const analysis = await this.astAnalyzer.analyze(filePath);
    
    // 2. 识别测试目标
    const testTargets = this.identifyTestTargets(analysis);
    
    // 3. 生成测试用例
    const tests: GeneratedTest[] = [];
    
    for (const target of testTargets) {
      const testCases = await this.generateTestCases(target);
      tests.push(...testCases);
    }
    
    return tests;
  }

  private identifyTestTargets(analysis: CodeAnalysis): TestTarget[] {
    const targets: TestTarget[] = [];
    
    // 识别公共函数
    for (const func of analysis.functions) {
      if (func.isPublic && !func.isTest) {
        targets.push({
          type: 'FUNCTION',
          name: func.name,
          signature: func.signature,
          complexity: func.complexity,
          dependencies: func.dependencies,
          returnType: func.returnType,
          parameters: func.parameters
        });
      }
    }
    
    // 识别类方法
    for (const cls of analysis.classes) {
      for (const method of cls.methods) {
        if (method.isPublic && !method.isTest) {
          targets.push({
            type: 'METHOD',
            className: cls.name,
            name: method.name,
            signature: method.signature,
            complexity: method.complexity,
            dependencies: method.dependencies,
            returnType: method.returnType,
            parameters: method.parameters
          });
        }
      }
    }
    
    return targets;
  }

  private async generateTestCases(target: TestTarget): Promise<GeneratedTest[]> {
    const testCases: GeneratedTest[] = [];
    
    // 1. 正常路径测试
    const happyPathTest = await this.generateHappyPathTest(target);
    testCases.push(happyPathTest);
    
    // 2. 边界条件测试
    const boundaryTests = await this.generateBoundaryTests(target);
    testCases.push(...boundaryTests);
    
    // 3. 异常路径测试
    const errorTests = await this.generateErrorTests(target);
    testCases.push(...errorTests);
    
    // 4. 性能测试
    if (target.complexity > 5) {
      const performanceTest = await this.generatePerformanceTest(target);
      testCases.push(performanceTest);
    }
    
    return testCases;
  }

  private async generateHappyPathTest(target: TestTarget): Promise<GeneratedTest> {
    const mocks = await this.mockGenerator.generateMocks(target.dependencies);
    const testData = this.generateTestData(target.parameters);
    
    return {
      name: `should ${this.generateTestDescription(target, 'happy_path')}`,
      type: 'UNIT',
      target,
      setup: mocks.setup,
      testData,
      assertions: this.generateAssertions(target, 'success'),
      cleanup: mocks.cleanup,
      code: await this.templateEngine.generateTestCode({
        target,
        mocks,
        testData,
        type: 'happy_path'
      })
    };
  }

  private async generateBoundaryTests(target: TestTarget): Promise<GeneratedTest[]> {
    const boundaryTests: GeneratedTest[] = [];
    
    for (const param of target.parameters) {
      const boundaryValues = this.generateBoundaryValues(param);
      
      for (const value of boundaryValues) {
        const mocks = await this.mockGenerator.generateMocks(target.dependencies);
        const testData = { ...this.generateTestData(target.parameters), [param.name]: value };
        
        boundaryTests.push({
          name: `should handle ${param.name} boundary value: ${value}`,
          type: 'UNIT',
          target,
          setup: mocks.setup,
          testData,
          assertions: this.generateAssertions(target, 'boundary'),
          cleanup: mocks.cleanup,
          code: await this.templateEngine.generateTestCode({
            target,
            mocks,
            testData,
            type: 'boundary',
            boundaryParam: param.name,
            boundaryValue: value
          })
        });
      }
    }
    
    return boundaryTests;
  }

  private generateBoundaryValues(param: Parameter): any[] {
    const values: any[] = [];
    
    switch (param.type) {
      case 'number':
        values.push(0, -1, 1, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, NaN, Infinity);
        break;
      case 'string':
        values.push('', ' ', 'a'.repeat(1000), '特殊字符!@#$%^&*()');
        break;
      case 'array':
        values.push([], [1], new Array(1000).fill(1));
        break;
      case 'object':
        values.push({}, null, undefined);
        break;
      default:
        values.push(null, undefined);
    }
    
    return values;
  }
}
```

### 2.3 测试覆盖率分析器

```typescript
class CoverageAnalyzer {
  private istanbulCollector: IstanbulCollector;
  private coverageReporter: CoverageReporter;
  private trendTracker: CoverageTrendTracker;

  constructor() {
    this.istanbulCollector = new IstanbulCollector();
    this.coverageReporter = new CoverageReporter();
    this.trendTracker = new CoverageTrendTracker();
  }

  async analyzeCoverage(testResults: TestResults): Promise<CoverageReport> {
    // 1. 收集覆盖率数据
    const rawCoverage = await this.istanbulCollector.collect(testResults);
    
    // 2. 分析覆�rate数据
    const analysis = this.analyzeCoverageData(rawCoverage);
    
    // 3. 识别未覆盖区域
    const uncoveredAreas = this.identifyUncoveredAreas(rawCoverage);
    
    // 4. 生成改进建议
    const recommendations = await this.generateCoverageRecommendations(analysis, uncoveredAreas);
    
    // 5. 跟踪趋势
    const trends = await this.trendTracker.track(analysis);
    
    const report: CoverageReport = {
      timestamp: new Date(),
      overall: analysis.overall,
      byFile: analysis.byFile,
      byFunction: analysis.byFunction,
      uncoveredAreas,
      recommendations,
      trends,
      qualityGate: this.evaluateQualityGate(analysis)
    };
    
    // 6. 生成报告
    await this.coverageReporter.generate(report);
    
    return report;
  }

  private analyzeCoverageData(rawCoverage: RawCoverage): CoverageAnalysis {
    const analysis: CoverageAnalysis = {
      overall: {
        lines: { covered: 0, total: 0, percentage: 0 },
        functions: { covered: 0, total: 0, percentage: 0 },
        branches: { covered: 0, total: 0, percentage: 0 },
        statements: { covered: 0, total: 0, percentage: 0 }
      },
      byFile: new Map(),
      byFunction: new Map()
    };

    for (const [filePath, fileData] of Object.entries(rawCoverage)) {
      const fileAnalysis = this.analyzeFileCoverage(fileData);
      analysis.byFile.set(filePath, fileAnalysis);
      
      // 累计到总体统计
      this.accumulateOverallStats(analysis.overall, fileAnalysis);
      
      // 分析函数级覆盖率
      for (const [funcName, funcData] of Object.entries(fileData.functions)) {
        const funcAnalysis = this.analyzeFunctionCoverage(funcData);
        analysis.byFunction.set(`${filePath}:${funcName}`, funcAnalysis);
      }
    }
    
    // 计算百分比
    this.calculatePercentages(analysis.overall);
    
    return analysis;
  }

  private identifyUncoveredAreas(rawCoverage: RawCoverage): UncoveredArea[] {
    const uncoveredAreas: UncoveredArea[] = [];
    
    for (const [filePath, fileData] of Object.entries(rawCoverage)) {
      // 识别未覆盖的行
      for (const [lineNum, lineData] of Object.entries(fileData.lines)) {
        if (lineData.count === 0) {
          uncoveredAreas.push({
            type: 'LINE',
            file: filePath,
            line: parseInt(lineNum),
            reason: this.analyzeUncoveredReason(fileData, parseInt(lineNum)),
            priority: this.calculateUncoveredPriority(fileData, parseInt(lineNum))
          });
        }
      }
      
      // 识别未覆盖的分支
      for (const [branchId, branchData] of Object.entries(fileData.branches)) {
        if (branchData.some(count => count === 0)) {
          uncoveredAreas.push({
            type: 'BRANCH',
            file: filePath,
            line: branchData.line,
            branch: branchId,
            reason: 'Branch not executed',
            priority: 'MEDIUM'
          });
        }
      }
    }
    
    return uncoveredAreas.sort((a, b) => this.comparePriority(a.priority, b.priority));
  }

  private async generateCoverageRecommendations(
    analysis: CoverageAnalysis,
    uncoveredAreas: UncoveredArea[]
  ): Promise<CoverageRecommendation[]> {
    const recommendations: CoverageRecommendation[] = [];
    
    // 基于整体覆盖率的建议
    if (analysis.overall.lines.percentage < 80) {
      recommendations.push({
        type: 'OVERALL_COVERAGE',
        priority: 'HIGH',
        title: '提升整体测试覆盖率',
        description: `当前行覆盖率为${analysis.overall.lines.percentage.toFixed(1)}%，建议提升至80%以上`,
        actions: [
          '为核心业务逻辑添加单元测试',
          '增加边界条件测试用例',
          '实施测试驱动开发(TDD)'
        ],
        estimatedEffort: '3-5天',
        targetCoverage: 80
      });
    }
    
    // 基于未覆盖区域的建议
    const highPriorityUncovered = uncoveredAreas.filter(area => area.priority === 'HIGH');
    if (highPriorityUncovered.length > 0) {
      recommendations.push({
        type: 'CRITICAL_AREAS',
        priority: 'HIGH',
        title: '覆盖关键未测试区域',
        description: `发现${highPriorityUncovered.length}个高优先级未覆盖区域`,
        actions: [
          '为关键业务逻辑添加测试',
          '覆盖错误处理路径',
          '测试异常情况处理'
        ],
        estimatedEffort: '2-3天',
        affectedAreas: highPriorityUncovered.slice(0, 10)
      });
    }
    
    return recommendations;
  }
}
```

## 3. 持续集成流水线

### 3.1 GitHub Actions配置

```yaml
# .github/workflows/ci.yml
name: Continuous Integration

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  NODE_VERSION: '18'
  CACHE_VERSION: 'v1'

jobs:
  # 代码质量检查
  code-quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: |
          npm run lint:check
          npm run lint:report

      - name: Run Prettier
        run: npm run format:check

      - name: Run TypeScript check
        run: npm run type-check

      - name: Run security audit
        run: |
          npm audit --audit-level moderate
          npm run security:check

      - name: Upload ESLint results
        uses: github/super-linter@v4
        if: always()
        env:
          DEFAULT_BRANCH: main
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # 单元测试
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [16, 18, 20]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: |
          npm run test:unit
          npm run test:coverage

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
          flags: unittests
          name: codecov-umbrella

  # 集成测试
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run database migrations
        run: npm run db:migrate
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db

      - name: Run integration tests
        run: npm run test:integration
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
          REDIS_URL: redis://localhost:6379

  # 端到端测试
  e2e-tests:
    name: E2E Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Start application
        run: |
          npm run start:test &
          npx wait-on http://localhost:3000

      - name: Run E2E tests
        run: npm run test:e2e

      - name: Upload E2E artifacts
        uses: actions/upload-artifact@v3
        if: failure()
        with:
          name: e2e-artifacts
          path: |
            tests/e2e/screenshots/
            tests/e2e/videos/

  # 性能测试
  performance-tests:
    name: Performance Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Run performance tests
        run: npm run test:performance

      - name: Upload performance results
        uses: actions/upload-artifact@v3
        with:
          name: performance-results
          path: performance-results/

  # SonarQube分析
  sonarqube:
    name: SonarQube Analysis
    runs-on: ubuntu-latest
    needs: [code-quality, unit-tests]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests with coverage
        run: npm run test:coverage

      - name: SonarQube Scan
        uses: sonarqube-quality-gate-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  # 质量门禁
  quality-gate:
    name: Quality Gate
    runs-on: ubuntu-latest
    needs: [code-quality, unit-tests, integration-tests, sonarqube]
    steps:
      - name: Check quality gate
        run: |
          echo "All quality checks passed!"
          echo "✅ Code quality: PASSED"
          echo "✅ Unit tests: PASSED"
          echo "✅ Integration tests: PASSED"
          echo "✅ SonarQube analysis: PASSED"
```

### 3.2 质量门禁系统

```typescript
class QualityGateSystem {
  private rules: QualityRule[];
  private metricsCollector: MetricsCollector;
  private notificationService: NotificationService;
  private reportGenerator: ReportGenerator;

  constructor() {
    this.rules = [];
    this.metricsCollector = new MetricsCollector();
    this.notificationService = new NotificationService();
    this.reportGenerator = new ReportGenerator();
    this.initializeQualityRules();
  }

  private initializeQualityRules(): void {
    // 代码覆盖率规则
    this.rules.push({
      name: 'test_coverage',
      description: '测试覆盖率必须达到80%',
      type: 'COVERAGE',
      threshold: 80,
      operator: 'GREATER_THAN_OR_EQUAL',
      severity: 'BLOCKER',
      enabled: true
    });

    // 代码质量规则
    this.rules.push({
      name: 'maintainability_rating',
      description: '可维护性评级必须为A',
      type: 'MAINTAINABILITY',
      threshold: 'A',
      operator: 'EQUALS',
      severity: 'BLOCKER',
      enabled: true
    });

    // 安全漏洞规则
    this.rules.push({
      name: 'security_vulnerabilities',
      description: '不允许存在高危安全漏洞',
      type: 'SECURITY',
      threshold: 0,
      operator: 'EQUALS',
      severity: 'BLOCKER',
      enabled: true
    });

    // 代码重复率规则
    this.rules.push({
      name: 'duplication_ratio',
      description: '代码重复率不能超过5%',
      type: 'DUPLICATION',
      threshold: 5,
      operator: 'LESS_THAN_OR_EQUAL',
      severity: 'MAJOR',
      enabled: true
    });

    // 复杂度规则
    this.rules.push({
      name: 'complexity_rating',
      description: '复杂度评级必须为A或B',
      type: 'COMPLEXITY',
      threshold: 'B',
      operator: 'LESS_THAN_OR_EQUAL',
      severity: 'MAJOR',
      enabled: true
    });
  }

  async evaluateQualityGate(projectPath: string, buildId: string): Promise<QualityGateResult> {
    const startTime = Date.now();
    
    try {
      // 1. 收集质量指标
      const metrics = await this.metricsCollector.collectAllMetrics(projectPath);
      
      // 2. 评估每个规则
      const ruleResults: RuleResult[] = [];
      
      for (const rule of this.rules.filter(r => r.enabled)) {
        const result = await this.evaluateRule(rule, metrics);
        ruleResults.push(result);
      }
      
      // 3. 计算整体结果
      const overallResult = this.calculateOverallResult(ruleResults);
      
      // 4. 生成详细报告
      const report = await this.generateQualityReport({
        buildId,
        projectPath,
        metrics,
        ruleResults,
        overallResult,
        timestamp: new Date(),
        duration: Date.now() - startTime
      });
      
      // 5. 发送通知
      await this.sendNotifications(report);
      
      return {
        passed: overallResult.status === 'PASSED',
        status: overallResult.status,
        score: overallResult.score,
        ruleResults,
        report,
        metrics
      };
      
    } catch (error) {
      console.error('Quality gate evaluation failed:', error);
      
      return {
        passed: false,
        status: 'ERROR',
        score: 0,
        ruleResults: [],
        error: error.message
      };
    }
  }

  private async evaluateRule(rule: QualityRule, metrics: QualityMetrics): Promise<RuleResult> {
    const metricValue = this.extractMetricValue(rule.type, metrics);
    const passed = this.compareValues(metricValue, rule.threshold, rule.operator);
    
    return {
      rule,
      passed,
      actualValue: metricValue,
      expectedValue: rule.threshold,
      message: passed 
        ? `✅ ${rule.description}` 
        : `❌ ${rule.description} (实际值: ${metricValue}, 期望: ${rule.operator} ${rule.threshold})`,
      severity: rule.severity
    };
  }

  private calculateOverallResult(ruleResults: RuleResult[]): OverallResult {
    const blockerFailures = ruleResults.filter(r => !r.passed && r.severity === 'BLOCKER');
    const criticalFailures = ruleResults.filter(r => !r.passed && r.severity === 'CRITICAL');
    const majorFailures = ruleResults.filter(r => !r.passed && r.severity === 'MAJOR');
    
    let status: QualityGateStatus;
    let score: number;
    
    if (blockerFailures.length > 0) {
      status = 'FAILED';
      score = 0;
    } else if (criticalFailures.length > 0) {
      status = 'WARNING';
      score = Math.max(0, 70 - criticalFailures.length * 10);
    } else if (majorFailures.length > 0) {
      status = 'WARNING';
      score = Math.max(0, 85 - majorFailures.length * 5);
    } else {
      status = 'PASSED';
      score = 100;
    }
    
    return {
      status,
      score,
      totalRules: ruleResults.length,
      passedRules: ruleResults.filter(r => r.passed).length,
      failedRules: ruleResults.filter(r => !r.passed).length,
      blockerFailures: blockerFailures.length,
      criticalFailures: criticalFailures.length,
      majorFailures: majorFailures.length
    };
  }

  private async sendNotifications(report: QualityGateReport): Promise<void> {
    const notifications: Notification[] = [];
    
    // 质量门禁失败通知
    if (report.overallResult.status === 'FAILED') {
      notifications.push({
        type: 'QUALITY_GATE_FAILED',
        severity: 'HIGH',
        title: '质量门禁检查失败',
        message: `构建 ${report.buildId} 未通过质量门禁检查`,
        details: report.ruleResults.filter(r => !r.passed),
        channels: ['email', 'slack', 'webhook']
      });
    }
    
    // 质量改善通知
    if (report.overallResult.score > 90) {
      notifications.push({
        type: 'QUALITY_IMPROVEMENT',
        severity: 'INFO',
        title: '代码质量优秀',
        message: `构建 ${report.buildId} 质量评分: ${report.overallResult.score}`,
        channels: ['slack']
      });
    }
    
    // 发送通知
    for (const notification of notifications) {
      await this.notificationService.send(notification);
    }
  }
}
```

## 4. 实施路线图

### 阶段一：基础工具链搭建 (1-2周)

1. **静态代码分析**
   - 配置ESLint和TypeScript
   - 集成SonarQube
   - 设置代码格式化工具

2. **基础测试框架**
   - 配置Jest测试框架
   - 实现单元测试模板
   - 设置测试覆盖率收集

3. **CI/CD基础**
   - 配置GitHub Actions
   - 实现基础构建流程
   - 设置质量门禁

### 阶段二：智能化工具集成 (2-3周)

1. **智能测试生成**
   - 实现AST分析器
   - 开发测试用例生成器
   - 集成Mock生成工具

2. **高级质量分析**
   - 部署复杂度分析工具
   - 实现技术债务计算
   - 配置安全漏洞扫描

3. **自动化报告**
   - 生成质量趋势报告
   - 实现智能建议系统
   - 配置通知机制

### 阶段三：企业级工具链 (3-4周)

1. **性能测试自动化**
   - 集成性能测试工具
   - 实现性能基线对比
   - 配置性能回归检测

2. **高级质量门禁**
   - 实现自适应质量标准
   - 配置多环境质量检查
   - 集成发布流程控制

3. **团队协作优化**
   - 实现代码审查自动化
   - 配置知识库集成
   - 建立最佳实践推荐

## 5. 预期工具链收益

### 技术收益
- **代码质量提升60%**：全面的静态分析和质量检测
- **测试效率提升200%**：智能测试生成和自动化执行
- **缺陷发现率提升80%**：多层次质量检查
- **发布风险降低90%**：严格的质量门禁控制

### 开发效率收益
- **代码审查时间减少50%**：自动化质量检查
- **测试编写时间减少70%**：智能测试生成
- **问题修复时间减少60%**：早期缺陷发现
- **发布频率提升300%**：自动化CI/CD流程

### 团队协作收益
- **代码一致性提升**：统一的代码规范和格式化
- **知识共享增强**：自动化文档和最佳实践
- **技能提升加速**：智能建议和学习资源
- **团队效率提升**：减少重复性工作

---

*本代码质量自动化工具链为3AI项目提供了全面的质量保障体系，通过静态分析、智能测试、持续集成、质量门禁等技术手段，构建现代化的软件开发质量管理平台。*