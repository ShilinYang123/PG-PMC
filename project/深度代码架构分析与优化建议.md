# 3AIé¡¹ç›®æ·±åº¦ä»£ç æ¶æ„åˆ†æä¸ä¼˜åŒ–å»ºè®®

## ğŸ“‹ å½“å‰æ¶æ„åˆ†æ

### ğŸ—ï¸ ç°æœ‰æ¶æ„æ¦‚è§ˆ

#### 1. **é¡¹ç›®ç»“æ„åˆ†æ**
```
3AIé¡¹ç›®æ¶æ„
â”œâ”€â”€ å‰ç«¯å±‚ (Client Layer)
â”‚   â”œâ”€â”€ TypeScript + Webpack
â”‚   â”œâ”€â”€ Tailwind CSS
â”‚   â””â”€â”€ å•é¡µåº”ç”¨æ¶æ„
â”œâ”€â”€ åç«¯å±‚ (Server Layer)
â”‚   â”œâ”€â”€ Express.js + TypeScript
â”‚   â”œâ”€â”€ ä¸­é—´ä»¶æ ˆ (Helmet, CORS, Rate Limiting)
â”‚   â””â”€â”€ RESTful APIè®¾è®¡
â”œâ”€â”€ é…ç½®å±‚ (Configuration Layer)
â”‚   â”œâ”€â”€ ç»Ÿä¸€é…ç½®ç®¡ç†
â”‚   â”œâ”€â”€ ç¯å¢ƒå˜é‡ç®¡ç†
â”‚   â””â”€â”€ YAMLé…ç½®æ–‡ä»¶
â””â”€â”€ æ„å»ºå±‚ (Build Layer)
    â”œâ”€â”€ TypeScriptç¼–è¯‘
    â”œâ”€â”€ Webpackæ‰“åŒ…
    â””â”€â”€ Dockerå®¹å™¨åŒ–
```

#### 2. **æ¶æ„ä¼˜åŠ¿**
- âœ… **ç±»å‹å®‰å…¨**: å…¨æ ˆTypeScriptå®ç°
- âœ… **æ¨¡å—åŒ–é…ç½®**: ç»Ÿä¸€é…ç½®ç®¡ç†ç³»ç»Ÿ
- âœ… **ç°ä»£æ„å»ºå·¥å…·**: Webpack + TypeScript
- âœ… **å®¹å™¨åŒ–æ”¯æŒ**: Dockeré…ç½®å®Œæ•´
- âœ… **ä»£ç è´¨é‡å·¥å…·**: ESLint + Prettier + Jest

#### 3. **æ¶æ„ç—›ç‚¹è¯†åˆ«**
- âš ï¸ **å•ä½“æ¶æ„**: å‰åç«¯è€¦åˆåº¦è¾ƒé«˜
- âš ï¸ **ç¼ºä¹åˆ†å±‚**: ä¸šåŠ¡é€»è¾‘ä¸è¡¨ç°å±‚æ··åˆ
- âš ï¸ **é…ç½®å¤æ‚**: å¤šä¸ªé…ç½®æ–‡ä»¶åˆ†æ•£ç®¡ç†
- âš ï¸ **ç¼ºä¹æŠ½è±¡**: ç›´æ¥ä½¿ç”¨Expressè€ŒéæŠ½è±¡å±‚
- âš ï¸ **æµ‹è¯•è¦†ç›–**: ç¼ºä¹å®Œæ•´çš„æµ‹è¯•ç­–ç•¥

## ğŸ¯ æ·±åº¦æ¶æ„ä¼˜åŒ–å»ºè®®

### 1. **é¢†åŸŸé©±åŠ¨è®¾è®¡ (DDD) æ¶æ„é‡æ„**

#### 1.1 åˆ†å±‚æ¶æ„å®ç°
```typescript
// src/domain/entities/User.ts
export class User {
  constructor(
    private readonly id: UserId,
    private readonly email: Email,
    private readonly profile: UserProfile
  ) {}

  public updateProfile(newProfile: UserProfile): void {
    // ä¸šåŠ¡è§„åˆ™éªŒè¯
    this.validateProfileUpdate(newProfile);
    this.profile = newProfile;
  }

  private validateProfileUpdate(profile: UserProfile): void {
    if (!profile.isValid()) {
      throw new InvalidProfileError('ç”¨æˆ·èµ„æ–™æ ¼å¼æ— æ•ˆ');
    }
  }
}

// src/domain/repositories/UserRepository.ts
export interface UserRepository {
  findById(id: UserId): Promise<User | null>;
  save(user: User): Promise<void>;
  findByEmail(email: Email): Promise<User | null>;
}

// src/application/services/UserService.ts
export class UserService {
  constructor(
    private readonly userRepository: UserRepository,
    private readonly eventBus: EventBus
  ) {}

  async updateUserProfile(userId: UserId, profileData: UserProfileData): Promise<void> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new UserNotFoundError('ç”¨æˆ·ä¸å­˜åœ¨');
    }

    const newProfile = UserProfile.fromData(profileData);
    user.updateProfile(newProfile);
    
    await this.userRepository.save(user);
    await this.eventBus.publish(new UserProfileUpdatedEvent(userId, newProfile));
  }
}
```

#### 1.2 å…­è¾¹å½¢æ¶æ„å®ç°
```typescript
// src/infrastructure/adapters/primary/web/UserController.ts
export class UserController {
  constructor(private readonly userService: UserService) {}

  async updateProfile(req: Request, res: Response): Promise<void> {
    try {
      const userId = UserId.fromString(req.params.id);
      const profileData = UserProfileData.fromRequest(req.body);
      
      await this.userService.updateUserProfile(userId, profileData);
      
      res.status(200).json({ success: true, message: 'ç”¨æˆ·èµ„æ–™æ›´æ–°æˆåŠŸ' });
    } catch (error) {
      this.handleError(error, res);
    }
  }

  private handleError(error: Error, res: Response): void {
    if (error instanceof UserNotFoundError) {
      res.status(404).json({ error: error.message });
    } else if (error instanceof InvalidProfileError) {
      res.status(400).json({ error: error.message });
    } else {
      res.status(500).json({ error: 'å†…éƒ¨æœåŠ¡å™¨é”™è¯¯' });
    }
  }
}

// src/infrastructure/adapters/secondary/persistence/PostgresUserRepository.ts
export class PostgresUserRepository implements UserRepository {
  constructor(private readonly db: Database) {}

  async findById(id: UserId): Promise<User | null> {
    const result = await this.db.query(
      'SELECT * FROM users WHERE id = $1',
      [id.value]
    );
    
    return result.rows[0] ? this.mapToUser(result.rows[0]) : null;
  }

  async save(user: User): Promise<void> {
    const userData = this.mapFromUser(user);
    await this.db.query(
      'UPDATE users SET email = $2, profile = $3 WHERE id = $1',
      [userData.id, userData.email, JSON.stringify(userData.profile)]
    );
  }

  private mapToUser(row: any): User {
    return new User(
      UserId.fromString(row.id),
      Email.fromString(row.email),
      UserProfile.fromJson(row.profile)
    );
  }
}
```

### 2. **å¾®æœåŠ¡æ¶æ„å‡†å¤‡**

#### 2.1 æœåŠ¡è¾¹ç•Œå®šä¹‰
```typescript
// src/services/user-service/UserServiceBoundary.ts
export interface UserServiceBoundary {
  // ç”¨æˆ·ç®¡ç†
  createUser(userData: CreateUserRequest): Promise<CreateUserResponse>;
  updateUser(userId: string, userData: UpdateUserRequest): Promise<UpdateUserResponse>;
  deleteUser(userId: string): Promise<void>;
  
  // ç”¨æˆ·æŸ¥è¯¢
  getUserById(userId: string): Promise<UserResponse>;
  getUsersByFilter(filter: UserFilter): Promise<UserListResponse>;
}

// src/services/auth-service/AuthServiceBoundary.ts
export interface AuthServiceBoundary {
  // è®¤è¯
  login(credentials: LoginRequest): Promise<LoginResponse>;
  logout(token: string): Promise<void>;
  refreshToken(refreshToken: string): Promise<TokenResponse>;
  
  // æˆæƒ
  validateToken(token: string): Promise<TokenValidationResponse>;
  checkPermission(userId: string, resource: string, action: string): Promise<boolean>;
}

// src/services/notification-service/NotificationServiceBoundary.ts
export interface NotificationServiceBoundary {
  // é€šçŸ¥å‘é€
  sendEmail(emailData: EmailRequest): Promise<void>;
  sendSMS(smsData: SMSRequest): Promise<void>;
  sendPushNotification(pushData: PushNotificationRequest): Promise<void>;
  
  // é€šçŸ¥æ¨¡æ¿
  createTemplate(template: NotificationTemplate): Promise<string>;
  updateTemplate(templateId: string, template: NotificationTemplate): Promise<void>;
}
```

#### 2.2 æœåŠ¡é—´é€šä¿¡è®¾è®¡
```typescript
// src/infrastructure/messaging/EventBus.ts
export class EventBus {
  private handlers: Map<string, Array<(event: DomainEvent) => Promise<void>>> = new Map();

  async publish(event: DomainEvent): Promise<void> {
    const eventType = event.constructor.name;
    const handlers = this.handlers.get(eventType) || [];
    
    await Promise.all(
      handlers.map(handler => this.handleEvent(handler, event))
    );
  }

  subscribe<T extends DomainEvent>(
    eventType: new (...args: any[]) => T,
    handler: (event: T) => Promise<void>
  ): void {
    const eventTypeName = eventType.name;
    if (!this.handlers.has(eventTypeName)) {
      this.handlers.set(eventTypeName, []);
    }
    this.handlers.get(eventTypeName)!.push(handler);
  }

  private async handleEvent(
    handler: (event: DomainEvent) => Promise<void>,
    event: DomainEvent
  ): Promise<void> {
    try {
      await handler(event);
    } catch (error) {
      console.error('äº‹ä»¶å¤„ç†å¤±è´¥:', error);
      // å¯ä»¥æ·»åŠ é‡è¯•é€»è¾‘æˆ–æ­»ä¿¡é˜Ÿåˆ—
    }
  }
}

// src/infrastructure/messaging/MessageQueue.ts
export class MessageQueue {
  constructor(private readonly redisClient: Redis) {}

  async publishMessage(queue: string, message: any): Promise<void> {
    await this.redisClient.lpush(queue, JSON.stringify({
      id: generateId(),
      timestamp: new Date().toISOString(),
      data: message
    }));
  }

  async consumeMessage(queue: string): Promise<any | null> {
    const result = await this.redisClient.brpop(queue, 0);
    return result ? JSON.parse(result[1]) : null;
  }

  async subscribeToQueue(
    queue: string,
    handler: (message: any) => Promise<void>
  ): Promise<void> {
    while (true) {
      try {
        const message = await this.consumeMessage(queue);
        if (message) {
          await handler(message.data);
        }
      } catch (error) {
        console.error('æ¶ˆæ¯å¤„ç†å¤±è´¥:', error);
        await new Promise(resolve => setTimeout(resolve, 1000)); // é‡è¯•å»¶è¿Ÿ
      }
    }
  }
}
```

### 3. **é«˜çº§è®¾è®¡æ¨¡å¼åº”ç”¨**

#### 3.1 CQRS (å‘½ä»¤æŸ¥è¯¢è´£ä»»åˆ†ç¦»)
```typescript
// src/application/commands/CreateUserCommand.ts
export class CreateUserCommand {
  constructor(
    public readonly email: string,
    public readonly password: string,
    public readonly profile: UserProfileData
  ) {}
}

export class CreateUserCommandHandler {
  constructor(
    private readonly userRepository: UserRepository,
    private readonly passwordHasher: PasswordHasher,
    private readonly eventBus: EventBus
  ) {}

  async handle(command: CreateUserCommand): Promise<UserId> {
    // éªŒè¯ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
    const existingUser = await this.userRepository.findByEmail(
      Email.fromString(command.email)
    );
    if (existingUser) {
      throw new UserAlreadyExistsError('ç”¨æˆ·å·²å­˜åœ¨');
    }

    // åˆ›å»ºæ–°ç”¨æˆ·
    const hashedPassword = await this.passwordHasher.hash(command.password);
    const user = User.create(
      Email.fromString(command.email),
      hashedPassword,
      UserProfile.fromData(command.profile)
    );

    await this.userRepository.save(user);
    await this.eventBus.publish(new UserCreatedEvent(user.id, user.email));

    return user.id;
  }
}

// src/application/queries/GetUserQuery.ts
export class GetUserQuery {
  constructor(public readonly userId: string) {}
}

export class GetUserQueryHandler {
  constructor(private readonly userReadModel: UserReadModel) {}

  async handle(query: GetUserQuery): Promise<UserView | null> {
    return await this.userReadModel.findById(query.userId);
  }
}

// src/infrastructure/readmodels/UserReadModel.ts
export class UserReadModel {
  constructor(private readonly db: Database) {}

  async findById(userId: string): Promise<UserView | null> {
    const result = await this.db.query(
      `SELECT u.id, u.email, u.created_at, p.display_name, p.avatar_url
       FROM users u
       LEFT JOIN user_profiles p ON u.id = p.user_id
       WHERE u.id = $1`,
      [userId]
    );

    return result.rows[0] ? this.mapToUserView(result.rows[0]) : null;
  }

  private mapToUserView(row: any): UserView {
    return {
      id: row.id,
      email: row.email,
      displayName: row.display_name,
      avatarUrl: row.avatar_url,
      createdAt: row.created_at
    };
  }
}
```

#### 3.2 ç­–ç•¥æ¨¡å¼ + å·¥å‚æ¨¡å¼
```typescript
// src/domain/services/NotificationStrategy.ts
export interface NotificationStrategy {
  send(recipient: string, message: string, options?: any): Promise<void>;
  validateRecipient(recipient: string): boolean;
}

export class EmailNotificationStrategy implements NotificationStrategy {
  constructor(private readonly emailService: EmailService) {}

  async send(recipient: string, message: string, options?: any): Promise<void> {
    if (!this.validateRecipient(recipient)) {
      throw new InvalidRecipientError('æ— æ•ˆçš„é‚®ç®±åœ°å€');
    }

    await this.emailService.sendEmail({
      to: recipient,
      subject: options?.subject || 'é€šçŸ¥',
      body: message,
      template: options?.template
    });
  }

  validateRecipient(recipient: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(recipient);
  }
}

export class SMSNotificationStrategy implements NotificationStrategy {
  constructor(private readonly smsService: SMSService) {}

  async send(recipient: string, message: string, options?: any): Promise<void> {
    if (!this.validateRecipient(recipient)) {
      throw new InvalidRecipientError('æ— æ•ˆçš„æ‰‹æœºå·ç ');
    }

    await this.smsService.sendSMS({
      to: recipient,
      message: message,
      template: options?.template
    });
  }

  validateRecipient(recipient: string): boolean {
    const phoneRegex = /^1[3-9]\d{9}$/;
    return phoneRegex.test(recipient);
  }
}

// src/domain/services/NotificationFactory.ts
export class NotificationFactory {
  private strategies: Map<NotificationType, NotificationStrategy> = new Map();

  constructor(
    emailService: EmailService,
    smsService: SMSService,
    pushService: PushNotificationService
  ) {
    this.strategies.set(NotificationType.EMAIL, new EmailNotificationStrategy(emailService));
    this.strategies.set(NotificationType.SMS, new SMSNotificationStrategy(smsService));
    this.strategies.set(NotificationType.PUSH, new PushNotificationStrategy(pushService));
  }

  getStrategy(type: NotificationType): NotificationStrategy {
    const strategy = this.strategies.get(type);
    if (!strategy) {
      throw new UnsupportedNotificationTypeError(`ä¸æ”¯æŒçš„é€šçŸ¥ç±»å‹: ${type}`);
    }
    return strategy;
  }

  async sendNotification(
    type: NotificationType,
    recipient: string,
    message: string,
    options?: any
  ): Promise<void> {
    const strategy = this.getStrategy(type);
    await strategy.send(recipient, message, options);
  }
}
```

### 4. **å“åº”å¼æ¶æ„è®¾è®¡**

#### 4.1 ååº”å¼æµå¤„ç†
```typescript
// src/infrastructure/reactive/ReactiveStream.ts
export class ReactiveStream<T> {
  private observers: Array<(value: T) => void> = [];
  private errorHandlers: Array<(error: Error) => void> = [];
  private completionHandlers: Array<() => void> = [];

  subscribe(
    onNext: (value: T) => void,
    onError?: (error: Error) => void,
    onComplete?: () => void
  ): Subscription {
    this.observers.push(onNext);
    if (onError) this.errorHandlers.push(onError);
    if (onComplete) this.completionHandlers.push(onComplete);

    return {
      unsubscribe: () => {
        this.observers = this.observers.filter(obs => obs !== onNext);
        if (onError) {
          this.errorHandlers = this.errorHandlers.filter(handler => handler !== onError);
        }
        if (onComplete) {
          this.completionHandlers = this.completionHandlers.filter(handler => handler !== onComplete);
        }
      }
    };
  }

  emit(value: T): void {
    this.observers.forEach(observer => {
      try {
        observer(value);
      } catch (error) {
        this.handleError(error);
      }
    });
  }

  error(error: Error): void {
    this.errorHandlers.forEach(handler => handler(error));
  }

  complete(): void {
    this.completionHandlers.forEach(handler => handler());
  }

  map<U>(transform: (value: T) => U): ReactiveStream<U> {
    const mapped = new ReactiveStream<U>();
    this.subscribe(
      value => mapped.emit(transform(value)),
      error => mapped.error(error),
      () => mapped.complete()
    );
    return mapped;
  }

  filter(predicate: (value: T) => boolean): ReactiveStream<T> {
    const filtered = new ReactiveStream<T>();
    this.subscribe(
      value => {
        if (predicate(value)) {
          filtered.emit(value);
        }
      },
      error => filtered.error(error),
      () => filtered.complete()
    );
    return filtered;
  }

  private handleError(error: Error): void {
    if (this.errorHandlers.length > 0) {
      this.errorHandlers.forEach(handler => handler(error));
    } else {
      console.error('æœªå¤„ç†çš„æµé”™è¯¯:', error);
    }
  }
}

interface Subscription {
  unsubscribe(): void;
}
```

#### 4.2 äº‹ä»¶æº¯æº (Event Sourcing)
```typescript
// src/infrastructure/eventsourcing/EventStore.ts
export class EventStore {
  constructor(private readonly db: Database) {}

  async saveEvents(aggregateId: string, events: DomainEvent[], expectedVersion: number): Promise<void> {
    const transaction = await this.db.beginTransaction();
    
    try {
      // æ£€æŸ¥ç‰ˆæœ¬å†²çª
      const currentVersion = await this.getCurrentVersion(aggregateId, transaction);
      if (currentVersion !== expectedVersion) {
        throw new ConcurrencyError('èšåˆç‰ˆæœ¬å†²çª');
      }

      // ä¿å­˜äº‹ä»¶
      for (let i = 0; i < events.length; i++) {
        const event = events[i];
        await transaction.query(
          `INSERT INTO events (aggregate_id, event_type, event_data, version, timestamp)
           VALUES ($1, $2, $3, $4, $5)`,
          [
            aggregateId,
            event.constructor.name,
            JSON.stringify(event),
            expectedVersion + i + 1,
            new Date()
          ]
        );
      }

      await transaction.commit();
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }

  async getEvents(aggregateId: string, fromVersion?: number): Promise<DomainEvent[]> {
    const query = fromVersion
      ? 'SELECT * FROM events WHERE aggregate_id = $1 AND version > $2 ORDER BY version'
      : 'SELECT * FROM events WHERE aggregate_id = $1 ORDER BY version';
    
    const params = fromVersion ? [aggregateId, fromVersion] : [aggregateId];
    const result = await this.db.query(query, params);

    return result.rows.map(row => this.deserializeEvent(row));
  }

  private async getCurrentVersion(aggregateId: string, transaction: any): Promise<number> {
    const result = await transaction.query(
      'SELECT MAX(version) as version FROM events WHERE aggregate_id = $1',
      [aggregateId]
    );
    return result.rows[0]?.version || 0;
  }

  private deserializeEvent(row: any): DomainEvent {
    const eventData = JSON.parse(row.event_data);
    // è¿™é‡Œéœ€è¦æ ¹æ®event_typeååºåˆ—åŒ–ä¸ºå…·ä½“çš„äº‹ä»¶ç±»å‹
    return this.createEventFromType(row.event_type, eventData);
  }

  private createEventFromType(eventType: string, eventData: any): DomainEvent {
    // äº‹ä»¶ç±»å‹æ³¨å†Œè¡¨
    const eventTypes: { [key: string]: new (...args: any[]) => DomainEvent } = {
      'UserCreatedEvent': UserCreatedEvent,
      'UserProfileUpdatedEvent': UserProfileUpdatedEvent,
      // æ·»åŠ æ›´å¤šäº‹ä»¶ç±»å‹
    };

    const EventClass = eventTypes[eventType];
    if (!EventClass) {
      throw new UnknownEventTypeError(`æœªçŸ¥çš„äº‹ä»¶ç±»å‹: ${eventType}`);
    }

    return new EventClass(eventData);
  }
}
```

## ğŸš€ å®æ–½è·¯çº¿å›¾

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€é‡æ„ (2-3å‘¨)
1. **åˆ†å±‚æ¶æ„å®æ–½**
   - åˆ›å»ºdomainã€applicationã€infrastructureå±‚
   - å®ç°åŸºç¡€çš„å®ä½“å’Œå€¼å¯¹è±¡
   - å»ºç«‹ä»“å‚¨æ¨¡å¼

2. **ä¾èµ–æ³¨å…¥å®¹å™¨**
   - å®ç°IoCå®¹å™¨
   - é…ç½®æœåŠ¡æ³¨å†Œ
   - é‡æ„ç°æœ‰ä»£ç ä½¿ç”¨DI

### ç¬¬äºŒé˜¶æ®µï¼šé«˜çº§æ¨¡å¼åº”ç”¨ (3-4å‘¨)
1. **CQRSå®æ–½**
   - åˆ†ç¦»å‘½ä»¤å’ŒæŸ¥è¯¢
   - å®ç°å‘½ä»¤å¤„ç†å™¨
   - å»ºç«‹è¯»æ¨¡å‹

2. **äº‹ä»¶é©±åŠ¨æ¶æ„**
   - å®ç°äº‹ä»¶æ€»çº¿
   - æ·»åŠ é¢†åŸŸäº‹ä»¶
   - å»ºç«‹äº‹ä»¶å¤„ç†å™¨

### ç¬¬ä¸‰é˜¶æ®µï¼šå¾®æœåŠ¡å‡†å¤‡ (4-5å‘¨)
1. **æœåŠ¡è¾¹ç•Œå®šä¹‰**
   - è¯†åˆ«ä¸šåŠ¡è¾¹ç•Œ
   - å®šä¹‰æœåŠ¡æ¥å£
   - å®ç°æœåŠ¡é—´é€šä¿¡

2. **æ•°æ®ä¸€è‡´æ€§**
   - å®ç°Sagaæ¨¡å¼
   - å»ºç«‹è¡¥å¿æœºåˆ¶
   - æ·»åŠ åˆ†å¸ƒå¼äº‹åŠ¡

## ğŸ“ˆ é¢„æœŸæ”¶ç›Š

### æŠ€æœ¯æ”¶ç›Š
- **å¯ç»´æŠ¤æ€§æå‡**: æ¸…æ™°çš„åˆ†å±‚æ¶æ„ï¼Œé™ä½è€¦åˆåº¦
- **å¯æ‰©å±•æ€§å¢å¼º**: å¾®æœåŠ¡æ¶æ„å‡†å¤‡ï¼Œæ”¯æŒæ°´å¹³æ‰©å±•
- **ä»£ç è´¨é‡**: é¢†åŸŸé©±åŠ¨è®¾è®¡ï¼Œä¸šåŠ¡é€»è¾‘æ¸…æ™°
- **æµ‹è¯•å‹å¥½**: ä¾èµ–æ³¨å…¥ï¼Œä¾¿äºå•å…ƒæµ‹è¯•

### ä¸šåŠ¡æ”¶ç›Š
- **å¼€å‘æ•ˆç‡**: æ¨¡å—åŒ–å¼€å‘ï¼Œå¹¶è¡Œå¼€å‘èƒ½åŠ›
- **ç³»ç»Ÿç¨³å®šæ€§**: äº‹ä»¶é©±åŠ¨æ¶æ„ï¼Œæ•…éšœéš”ç¦»
- **ä¸šåŠ¡æ•æ·æ€§**: CQRSæ¨¡å¼ï¼Œè¯»å†™åˆ†ç¦»ä¼˜åŒ–
- **å›¢é˜Ÿåä½œ**: æ¸…æ™°çš„æ¶æ„è¾¹ç•Œï¼Œå‡å°‘å†²çª

---

**æ¨è€å¸ˆï¼Œè¿™ä»½æ·±åº¦æ¶æ„åˆ†æä¸º3AIé¡¹ç›®æä¾›äº†ä»å•ä½“åˆ°å¾®æœåŠ¡çš„å®Œæ•´æ¼”è¿›è·¯å¾„ã€‚å»ºè®®ä»åˆ†å±‚æ¶æ„å¼€å§‹å®æ–½ï¼Œé€æ­¥å¼•å…¥é«˜çº§è®¾è®¡æ¨¡å¼ï¼Œæœ€ç»ˆå®ç°ä¼ä¸šçº§çš„å¯æ‰©å±•æ¶æ„ã€‚**