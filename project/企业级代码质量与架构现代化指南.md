# 3AIé¡¹ç›®ä¼ä¸šçº§ä»£ç è´¨é‡ä¸æ¶æ„ç°ä»£åŒ–æŒ‡å—

## æ¨è€å¸ˆï¼Œæ‚¨å¥½ï¼

åŸºäºå¯¹3AIé¡¹ç›®çš„æ·±åº¦åˆ†æï¼Œæˆ‘ä¸ºæ‚¨æä¾›ä¼ä¸šçº§çš„ä»£ç è´¨é‡å’Œæ¶æ„ç°ä»£åŒ–å»ºè®®ï¼Œè¿™äº›å°†å¸®åŠ©é¡¹ç›®è¾¾åˆ°è¡Œä¸šé¢†å…ˆæ°´å¹³ã€‚

## ğŸ—ï¸ ç°ä»£åŒ–æ¶æ„æ¨¡å¼æ·±åº¦åº”ç”¨

### 1. å¾®æœåŠ¡æ¶æ„æ¸è¿›å¼æ¼”è¿›

#### 1.1 å•ä½“åˆ°å¾®æœåŠ¡çš„å¹³æ»‘è¿‡æ¸¡

```typescript
// src/architecture/ServiceBoundary.ts
/**
 * æœåŠ¡è¾¹ç•Œå®šä¹‰ - ä¸ºæœªæ¥å¾®æœåŠ¡æ‹†åˆ†åšå‡†å¤‡
 */
export interface ServiceBoundary {
  name: string;
  domain: string;
  responsibilities: string[];
  dependencies: string[];
  apis: ServiceAPI[];
  events: DomainEvent[];
}

export interface ServiceAPI {
  endpoint: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  purpose: string;
  inputSchema: object;
  outputSchema: object;
}

export interface DomainEvent {
  name: string;
  payload: object;
  triggers: string[];
  consumers: string[];
}

// ç”¨æˆ·æœåŠ¡è¾¹ç•Œå®šä¹‰
export const UserServiceBoundary: ServiceBoundary = {
  name: 'UserService',
  domain: 'User Management',
  responsibilities: [
    'ç”¨æˆ·æ³¨å†Œå’Œè®¤è¯',
    'ç”¨æˆ·ä¿¡æ¯ç®¡ç†',
    'æƒé™æ§åˆ¶',
    'ç”¨æˆ·åå¥½è®¾ç½®'
  ],
  dependencies: [
    'NotificationService',
    'AuditService'
  ],
  apis: [
    {
      endpoint: '/api/users',
      method: 'POST',
      purpose: 'åˆ›å»ºæ–°ç”¨æˆ·',
      inputSchema: {
        type: 'object',
        properties: {
          email: { type: 'string', format: 'email' },
          name: { type: 'string', minLength: 2 },
          password: { type: 'string', minLength: 8 }
        },
        required: ['email', 'name', 'password']
      },
      outputSchema: {
        type: 'object',
        properties: {
          id: { type: 'string' },
          email: { type: 'string' },
          name: { type: 'string' },
          createdAt: { type: 'string', format: 'date-time' }
        }
      }
    }
  ],
  events: [
    {
      name: 'UserCreated',
      payload: {
        userId: 'string',
        email: 'string',
        name: 'string',
        timestamp: 'string'
      },
      triggers: ['ç”¨æˆ·æ³¨å†ŒæˆåŠŸ'],
      consumers: ['NotificationService', 'AuditService', 'AnalyticsService']
    }
  ]
};
```

#### 1.2 äº‹ä»¶é©±åŠ¨æ¶æ„å®ç°

```typescript
// src/events/EventBus.ts
import { EventEmitter } from 'events';
import { logger } from '../utils/logger';

export interface DomainEvent {
  id: string;
  type: string;
  aggregateId: string;
  aggregateType: string;
  version: number;
  timestamp: Date;
  payload: any;
  metadata?: Record<string, any>;
}

export interface EventHandler<T = any> {
  handle(event: DomainEvent<T>): Promise<void>;
  canHandle(eventType: string): boolean;
  getHandlerName(): string;
}

export class EventBus {
  private emitter: EventEmitter;
  private handlers: Map<string, EventHandler[]>;
  private eventStore: DomainEvent[];
  private retryQueue: Map<string, { event: DomainEvent; attempts: number }>;
  private maxRetries: number = 3;

  constructor() {
    this.emitter = new EventEmitter();
    this.handlers = new Map();
    this.eventStore = [];
    this.retryQueue = new Map();
    this.setupErrorHandling();
  }

  /**
   * å‘å¸ƒé¢†åŸŸäº‹ä»¶
   */
  async publish(event: DomainEvent): Promise<void> {
    try {
      // æŒä¹…åŒ–äº‹ä»¶
      await this.persistEvent(event);
      
      // è®°å½•äº‹ä»¶å‘å¸ƒ
      logger.info('äº‹ä»¶å·²å‘å¸ƒ', {
        eventId: event.id,
        eventType: event.type,
        aggregateId: event.aggregateId
      });
      
      // å¼‚æ­¥å¤„ç†äº‹ä»¶
      this.emitter.emit(event.type, event);
      
      // å¤„ç†äº‹ä»¶å¤„ç†å™¨
      const handlers = this.handlers.get(event.type) || [];
      await this.processHandlers(event, handlers);
      
    } catch (error) {
      logger.error('äº‹ä»¶å‘å¸ƒå¤±è´¥', {
        eventId: event.id,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * è®¢é˜…äº‹ä»¶å¤„ç†å™¨
   */
  subscribe<T>(eventType: string, handler: EventHandler<T>): void {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, []);
    }
    
    this.handlers.get(eventType)!.push(handler);
    
    logger.info('äº‹ä»¶å¤„ç†å™¨å·²æ³¨å†Œ', {
      eventType,
      handlerName: handler.getHandlerName()
    });
  }

  /**
   * å¤„ç†äº‹ä»¶å¤„ç†å™¨
   */
  private async processHandlers(event: DomainEvent, handlers: EventHandler[]): Promise<void> {
    const promises = handlers.map(async (handler) => {
      try {
        if (handler.canHandle(event.type)) {
          await handler.handle(event);
          logger.debug('äº‹ä»¶å¤„ç†æˆåŠŸ', {
            eventId: event.id,
            handlerName: handler.getHandlerName()
          });
        }
      } catch (error) {
        logger.error('äº‹ä»¶å¤„ç†å¤±è´¥', {
          eventId: event.id,
          handlerName: handler.getHandlerName(),
          error: error.message
        });
        
        // æ·»åŠ åˆ°é‡è¯•é˜Ÿåˆ—
        await this.addToRetryQueue(event, handler);
      }
    });
    
    await Promise.allSettled(promises);
  }

  /**
   * é‡è¯•æœºåˆ¶
   */
  private async addToRetryQueue(event: DomainEvent, handler: EventHandler): Promise<void> {
    const retryKey = `${event.id}_${handler.getHandlerName()}`;
    const retryInfo = this.retryQueue.get(retryKey) || { event, attempts: 0 };
    
    if (retryInfo.attempts < this.maxRetries) {
      retryInfo.attempts++;
      this.retryQueue.set(retryKey, retryInfo);
      
      // å»¶è¿Ÿé‡è¯•
      setTimeout(async () => {
        try {
          await handler.handle(event);
          this.retryQueue.delete(retryKey);
          logger.info('äº‹ä»¶é‡è¯•å¤„ç†æˆåŠŸ', {
            eventId: event.id,
            handlerName: handler.getHandlerName(),
            attempts: retryInfo.attempts
          });
        } catch (error) {
          logger.error('äº‹ä»¶é‡è¯•å¤„ç†å¤±è´¥', {
            eventId: event.id,
            handlerName: handler.getHandlerName(),
            attempts: retryInfo.attempts,
            error: error.message
          });
          
          if (retryInfo.attempts >= this.maxRetries) {
            await this.handleDeadLetter(event, handler, error);
          } else {
            await this.addToRetryQueue(event, handler);
          }
        }
      }, Math.pow(2, retryInfo.attempts) * 1000); // æŒ‡æ•°é€€é¿
    } else {
      await this.handleDeadLetter(event, handler, new Error('è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°'));
    }
  }

  /**
   * æ­»ä¿¡å¤„ç†
   */
  private async handleDeadLetter(event: DomainEvent, handler: EventHandler, error: Error): Promise<void> {
    logger.error('äº‹ä»¶è¿›å…¥æ­»ä¿¡é˜Ÿåˆ—', {
      eventId: event.id,
      handlerName: handler.getHandlerName(),
      error: error.message
    });
    
    // è¿™é‡Œå¯ä»¥å°†äº‹ä»¶å‘é€åˆ°æ­»ä¿¡é˜Ÿåˆ—æˆ–é€šçŸ¥ç®¡ç†å‘˜
    // await deadLetterQueue.send(event, handler, error);
  }

  /**
   * æŒä¹…åŒ–äº‹ä»¶
   */
  private async persistEvent(event: DomainEvent): Promise<void> {
    // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥æŒä¹…åŒ–åˆ°æ•°æ®åº“
    this.eventStore.push(event);
  }

  /**
   * è®¾ç½®é”™è¯¯å¤„ç†
   */
  private setupErrorHandling(): void {
    this.emitter.on('error', (error) => {
      logger.error('EventBusé”™è¯¯', { error: error.message });
    });
  }

  /**
   * è·å–äº‹ä»¶å†å²
   */
  getEventHistory(aggregateId: string): DomainEvent[] {
    return this.eventStore.filter(event => event.aggregateId === aggregateId);
  }

  /**
   * é‡æ”¾äº‹ä»¶
   */
  async replayEvents(aggregateId: string, fromVersion?: number): Promise<void> {
    const events = this.getEventHistory(aggregateId)
      .filter(event => !fromVersion || event.version >= fromVersion)
      .sort((a, b) => a.version - b.version);
    
    for (const event of events) {
      await this.publish(event);
    }
  }
}

// äº‹ä»¶å¤„ç†å™¨ç¤ºä¾‹
export class UserCreatedHandler implements EventHandler {
  constructor(
    private notificationService: any,
    private auditService: any
  ) {}

  async handle(event: DomainEvent): Promise<void> {
    const { userId, email, name } = event.payload;
    
    // å‘é€æ¬¢è¿é‚®ä»¶
    await this.notificationService.sendWelcomeEmail(email, name);
    
    // è®°å½•å®¡è®¡æ—¥å¿—
    await this.auditService.logUserCreation(userId, {
      timestamp: event.timestamp,
      metadata: event.metadata
    });
  }

  canHandle(eventType: string): boolean {
    return eventType === 'UserCreated';
  }

  getHandlerName(): string {
    return 'UserCreatedHandler';
  }
}
```

### 2. é«˜çº§ç¼“å­˜ç­–ç•¥ä¸æ•°æ®ä¸€è‡´æ€§

#### 2.1 å¤šå±‚ç¼“å­˜æ¶æ„

```typescript
// src/cache/CacheManager.ts
import Redis from 'ioredis';
import { LRUCache } from 'lru-cache';
import { logger } from '../utils/logger';

export interface CacheConfig {
  redis: {
    host: string;
    port: number;
    password?: string;
    db: number;
  };
  memory: {
    maxSize: number;
    ttl: number;
  };
  strategies: {
    writeThrough: boolean;
    writeBack: boolean;
    readThrough: boolean;
  };
}

export interface CacheEntry<T> {
  value: T;
  timestamp: number;
  ttl: number;
  version: number;
  tags: string[];
}

export class CacheManager {
  private redis: Redis;
  private memoryCache: LRUCache<string, CacheEntry<any>>;
  private config: CacheConfig;
  private hitStats: Map<string, { hits: number; misses: number }>;

  constructor(config: CacheConfig) {
    this.config = config;
    this.redis = new Redis(config.redis);
    this.memoryCache = new LRUCache({
      max: config.memory.maxSize,
      ttl: config.memory.ttl * 1000
    });
    this.hitStats = new Map();
    this.setupEventHandlers();
  }

  /**
   * æ™ºèƒ½ç¼“å­˜è·å– - L1(å†…å­˜) -> L2(Redis) -> æ•°æ®æº
   */
  async get<T>(key: string, fallback?: () => Promise<T>, ttl?: number): Promise<T | null> {
    const startTime = Date.now();
    
    try {
      // L1: å†…å­˜ç¼“å­˜
      const memoryEntry = this.memoryCache.get(key);
      if (memoryEntry && !this.isExpired(memoryEntry)) {
        this.recordHit(key, 'memory');
        logger.debug('ç¼“å­˜å‘½ä¸­ (å†…å­˜)', { key, responseTime: Date.now() - startTime });
        return memoryEntry.value;
      }

      // L2: Redisç¼“å­˜
      const redisValue = await this.redis.get(key);
      if (redisValue) {
        const entry: CacheEntry<T> = JSON.parse(redisValue);
        if (!this.isExpired(entry)) {
          // å›å†™åˆ°å†…å­˜ç¼“å­˜
          this.memoryCache.set(key, entry);
          this.recordHit(key, 'redis');
          logger.debug('ç¼“å­˜å‘½ä¸­ (Redis)', { key, responseTime: Date.now() - startTime });
          return entry.value;
        }
      }

      // L3: æ•°æ®æº
      if (fallback) {
        const value = await fallback();
        if (value !== null && value !== undefined) {
          await this.set(key, value, ttl);
          this.recordMiss(key);
          logger.debug('ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ•°æ®æºè·å–', { key, responseTime: Date.now() - startTime });
          return value;
        }
      }

      this.recordMiss(key);
      return null;
    } catch (error) {
      logger.error('ç¼“å­˜è·å–å¤±è´¥', { key, error: error.message });
      if (fallback) {
        return await fallback();
      }
      return null;
    }
  }

  /**
   * æ™ºèƒ½ç¼“å­˜è®¾ç½®
   */
  async set<T>(key: string, value: T, ttl?: number, tags?: string[]): Promise<void> {
    const entry: CacheEntry<T> = {
      value,
      timestamp: Date.now(),
      ttl: ttl || 3600,
      version: 1,
      tags: tags || []
    };

    try {
      // å†™å…¥å†…å­˜ç¼“å­˜
      this.memoryCache.set(key, entry);
      
      // å†™å…¥Redisç¼“å­˜
      await this.redis.setex(key, entry.ttl, JSON.stringify(entry));
      
      // å¦‚æœæœ‰æ ‡ç­¾ï¼Œå»ºç«‹æ ‡ç­¾ç´¢å¼•
      if (tags && tags.length > 0) {
        await this.indexTags(key, tags);
      }
      
      logger.debug('ç¼“å­˜å·²è®¾ç½®', { key, ttl: entry.ttl, tags });
    } catch (error) {
      logger.error('ç¼“å­˜è®¾ç½®å¤±è´¥', { key, error: error.message });
    }
  }

  /**
   * æŒ‰æ ‡ç­¾æ‰¹é‡å¤±æ•ˆ
   */
  async invalidateByTags(tags: string[]): Promise<void> {
    try {
      const keys = new Set<string>();
      
      for (const tag of tags) {
        const tagKeys = await this.redis.smembers(`tag:${tag}`);
        tagKeys.forEach(key => keys.add(key));
      }
      
      if (keys.size > 0) {
        const keyArray = Array.from(keys);
        
        // ä»å†…å­˜ç¼“å­˜åˆ é™¤
        keyArray.forEach(key => this.memoryCache.delete(key));
        
        // ä»Redisåˆ é™¤
        await this.redis.del(...keyArray);
        
        // æ¸…ç†æ ‡ç­¾ç´¢å¼•
        for (const tag of tags) {
          await this.redis.del(`tag:${tag}`);
        }
        
        logger.info('æŒ‰æ ‡ç­¾æ‰¹é‡å¤±æ•ˆç¼“å­˜', { tags, keysCount: keys.size });
      }
    } catch (error) {
      logger.error('æŒ‰æ ‡ç­¾å¤±æ•ˆç¼“å­˜å¤±è´¥', { tags, error: error.message });
    }
  }

  /**
   * ç¼“å­˜é¢„çƒ­
   */
  async warmup(warmupData: Array<{ key: string; loader: () => Promise<any>; ttl?: number; tags?: string[] }>): Promise<void> {
    logger.info('å¼€å§‹ç¼“å­˜é¢„çƒ­', { itemsCount: warmupData.length });
    
    const promises = warmupData.map(async ({ key, loader, ttl, tags }) => {
      try {
        const value = await loader();
        await this.set(key, value, ttl, tags);
        logger.debug('ç¼“å­˜é¢„çƒ­æˆåŠŸ', { key });
      } catch (error) {
        logger.error('ç¼“å­˜é¢„çƒ­å¤±è´¥', { key, error: error.message });
      }
    });
    
    await Promise.allSettled(promises);
    logger.info('ç¼“å­˜é¢„çƒ­å®Œæˆ');
  }

  /**
   * ç¼“å­˜ç»Ÿè®¡
   */
  getStats(): Record<string, any> {
    const stats = {
      memory: {
        size: this.memoryCache.size,
        maxSize: this.memoryCache.max
      },
      hitRates: {} as Record<string, number>
    };
    
    this.hitStats.forEach((stat, key) => {
      const total = stat.hits + stat.misses;
      stats.hitRates[key] = total > 0 ? (stat.hits / total) * 100 : 0;
    });
    
    return stats;
  }

  /**
   * ç¼“å­˜å¥åº·æ£€æŸ¥
   */
  async healthCheck(): Promise<{ status: 'healthy' | 'degraded' | 'unhealthy'; details: any }> {
    try {
      const testKey = 'health_check_' + Date.now();
      const testValue = 'test';
      
      // æµ‹è¯•å†™å…¥
      await this.set(testKey, testValue, 10);
      
      // æµ‹è¯•è¯»å–
      const retrievedValue = await this.get(testKey);
      
      // æ¸…ç†æµ‹è¯•æ•°æ®
      await this.delete(testKey);
      
      if (retrievedValue === testValue) {
        return {
          status: 'healthy',
          details: {
            redis: 'connected',
            memory: 'operational',
            stats: this.getStats()
          }
        };
      } else {
        return {
          status: 'degraded',
          details: {
            issue: 'ç¼“å­˜è¯»å†™ä¸ä¸€è‡´',
            stats: this.getStats()
          }
        };
      }
    } catch (error) {
      return {
        status: 'unhealthy',
        details: {
          error: error.message,
          stats: this.getStats()
        }
      };
    }
  }

  private async indexTags(key: string, tags: string[]): Promise<void> {
    const pipeline = this.redis.pipeline();
    tags.forEach(tag => {
      pipeline.sadd(`tag:${tag}`, key);
    });
    await pipeline.exec();
  }

  private isExpired(entry: CacheEntry<any>): boolean {
    return Date.now() - entry.timestamp > entry.ttl * 1000;
  }

  private recordHit(key: string, source: string): void {
    const statKey = `${key}_${source}`;
    const stat = this.hitStats.get(statKey) || { hits: 0, misses: 0 };
    stat.hits++;
    this.hitStats.set(statKey, stat);
  }

  private recordMiss(key: string): void {
    const stat = this.hitStats.get(key) || { hits: 0, misses: 0 };
    stat.misses++;
    this.hitStats.set(key, stat);
  }

  private setupEventHandlers(): void {
    this.redis.on('error', (error) => {
      logger.error('Redisè¿æ¥é”™è¯¯', { error: error.message });
    });
    
    this.redis.on('connect', () => {
      logger.info('Redisè¿æ¥æˆåŠŸ');
    });
  }

  async delete(key: string): Promise<void> {
    this.memoryCache.delete(key);
    await this.redis.del(key);
  }

  async clear(): Promise<void> {
    this.memoryCache.clear();
    await this.redis.flushdb();
  }
}
```

### 3. é«˜çº§å®‰å…¨é˜²æŠ¤ä½“ç³»

#### 3.1 å¤šå±‚å®‰å…¨ä¸­é—´ä»¶

```typescript
// src/security/SecurityMiddleware.ts
import { Request, Response, NextFunction } from 'express';
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import { body, validationResult } from 'express-validator';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import { logger } from '../utils/logger';

export interface SecurityConfig {
  rateLimit: {
    windowMs: number;
    max: number;
    skipSuccessfulRequests: boolean;
  };
  jwt: {
    secret: string;
    expiresIn: string;
    refreshExpiresIn: string;
  };
  encryption: {
    algorithm: string;
    keyLength: number;
  };
  csrf: {
    enabled: boolean;
    cookieName: string;
  };
}

export class SecurityMiddleware {
  private config: SecurityConfig;
  private suspiciousIPs: Map<string, { attempts: number; lastAttempt: Date }> = new Map();
  private encryptionKey: Buffer;

  constructor(config: SecurityConfig) {
    this.config = config;
    this.encryptionKey = crypto.randomBytes(config.encryption.keyLength);
  }

  /**
   * åŸºç¡€å®‰å…¨å¤´è®¾ç½®
   */
  basicSecurity() {
    return helmet({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'", 'https://fonts.googleapis.com'],
          fontSrc: ["'self'", 'https://fonts.gstatic.com'],
          imgSrc: ["'self'", 'data:', 'https:'],
          scriptSrc: ["'self'"],
          connectSrc: ["'self'"],
          frameSrc: ["'none'"],
          objectSrc: ["'none'"],
          upgradeInsecureRequests: []
        }
      },
      hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
      },
      noSniff: true,
      xssFilter: true,
      referrerPolicy: { policy: 'strict-origin-when-cross-origin' }
    });
  }

  /**
   * æ™ºèƒ½é€Ÿç‡é™åˆ¶
   */
  intelligentRateLimit() {
    return rateLimit({
      windowMs: this.config.rateLimit.windowMs,
      max: (req: Request) => {
        // æ ¹æ®ç”¨æˆ·ç±»å‹å’Œç«¯ç‚¹è°ƒæ•´é™åˆ¶
        if (req.path.startsWith('/api/auth/')) {
          return 5; // è®¤è¯ç«¯ç‚¹æ›´ä¸¥æ ¼
        }
        if (req.headers.authorization) {
          return this.config.rateLimit.max * 2; // å·²è®¤è¯ç”¨æˆ·æ›´å®½æ¾
        }
        return this.config.rateLimit.max;
      },
      skipSuccessfulRequests: this.config.rateLimit.skipSuccessfulRequests,
      keyGenerator: (req: Request) => {
        // ç»„åˆIPå’Œç”¨æˆ·IDä½œä¸ºé™åˆ¶é”®
        const ip = this.getClientIP(req);
        const userId = req.user?.id || 'anonymous';
        return `${ip}:${userId}`;
      },
      onLimitReached: (req: Request) => {
        const ip = this.getClientIP(req);
        this.recordSuspiciousActivity(ip, 'rate_limit_exceeded');
        logger.warn('é€Ÿç‡é™åˆ¶è§¦å‘', {
          ip,
          path: req.path,
          userAgent: req.headers['user-agent']
        });
      }
    });
  }

  /**
   * JWTè®¤è¯ä¸­é—´ä»¶
   */
  jwtAuth() {
    return async (req: Request, res: Response, next: NextFunction) => {
      try {
        const token = this.extractToken(req);
        
        if (!token) {
          return res.status(401).json({
            success: false,
            error: {
              code: 'MISSING_TOKEN',
              message: 'ç¼ºå°‘è®¤è¯ä»¤ç‰Œ'
            }
          });
        }

        const decoded = jwt.verify(token, this.config.jwt.secret) as any;
        
        // æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦åœ¨é»‘åå•ä¸­
        if (await this.isTokenBlacklisted(token)) {
          return res.status(401).json({
            success: false,
            error: {
              code: 'TOKEN_BLACKLISTED',
              message: 'ä»¤ç‰Œå·²å¤±æ•ˆ'
            }
          });
        }

        // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
        if (!(await this.isUserValid(decoded.userId))) {
          return res.status(401).json({
            success: false,
            error: {
              code: 'USER_INVALID',
              message: 'ç”¨æˆ·è´¦æˆ·æ— æ•ˆ'
            }
          });
        }

        req.user = decoded;
        next();
      } catch (error) {
        if (error.name === 'TokenExpiredError') {
          return res.status(401).json({
            success: false,
            error: {
              code: 'TOKEN_EXPIRED',
              message: 'ä»¤ç‰Œå·²è¿‡æœŸ'
            }
          });
        }
        
        logger.error('JWTè®¤è¯å¤±è´¥', {
          error: error.message,
          ip: this.getClientIP(req)
        });
        
        return res.status(401).json({
          success: false,
          error: {
            code: 'INVALID_TOKEN',
            message: 'æ— æ•ˆçš„è®¤è¯ä»¤ç‰Œ'
          }
        });
      }
    };
  }

  /**
   * è¾“å…¥éªŒè¯å’Œæ¸…ç†
   */
  inputValidation(validationRules: any[]) {
    return [
      ...validationRules,
      (req: Request, res: Response, next: NextFunction) => {
        const errors = validationResult(req);
        
        if (!errors.isEmpty()) {
          const sanitizedErrors = errors.array().map(error => ({
            field: error.param,
            message: this.sanitizeErrorMessage(error.msg),
            value: this.sanitizeValue(error.value)
          }));
          
          logger.warn('è¾“å…¥éªŒè¯å¤±è´¥', {
            ip: this.getClientIP(req),
            path: req.path,
            errors: sanitizedErrors
          });
          
          return res.status(400).json({
            success: false,
            error: {
              code: 'VALIDATION_ERROR',
              message: 'è¾“å…¥æ•°æ®éªŒè¯å¤±è´¥',
              details: sanitizedErrors
            }
          });
        }
        
        // æ¸…ç†è¾“å…¥æ•°æ®
        req.body = this.sanitizeObject(req.body);
        req.query = this.sanitizeObject(req.query);
        
        next();
      }
    ];
  }

  /**
   * SQLæ³¨å…¥é˜²æŠ¤
   */
  sqlInjectionProtection() {
    return (req: Request, res: Response, next: NextFunction) => {
      const suspiciousPatterns = [
        /('|(\-\-)|(;)|(\||\|)|(\*|\*))/i,
        /(union|select|insert|delete|update|drop|create|alter|exec|execute)/i,
        /(script|javascript|vbscript|onload|onerror|onclick)/i
      ];
      
      const checkValue = (value: any): boolean => {
        if (typeof value === 'string') {
          return suspiciousPatterns.some(pattern => pattern.test(value));
        }
        if (typeof value === 'object' && value !== null) {
          return Object.values(value).some(checkValue);
        }
        return false;
      };
      
      if (checkValue(req.body) || checkValue(req.query) || checkValue(req.params)) {
        const ip = this.getClientIP(req);
        this.recordSuspiciousActivity(ip, 'sql_injection_attempt');
        
        logger.error('æ£€æµ‹åˆ°SQLæ³¨å…¥å°è¯•', {
          ip,
          path: req.path,
          userAgent: req.headers['user-agent'],
          body: this.sanitizeObject(req.body),
          query: this.sanitizeObject(req.query)
        });
        
        return res.status(400).json({
          success: false,
          error: {
            code: 'MALICIOUS_INPUT',
            message: 'æ£€æµ‹åˆ°æ¶æ„è¾“å…¥'
          }
        });
      }
      
      next();
    };
  }

  /**
   * CSRFä¿æŠ¤
   */
  csrfProtection() {
    return (req: Request, res: Response, next: NextFunction) => {
      if (!this.config.csrf.enabled) {
        return next();
      }
      
      if (['GET', 'HEAD', 'OPTIONS'].includes(req.method)) {
        return next();
      }
      
      const token = req.headers['x-csrf-token'] || req.body._csrf;
      const sessionToken = req.session?.csrfToken;
      
      if (!token || !sessionToken || token !== sessionToken) {
        logger.warn('CSRFä»¤ç‰ŒéªŒè¯å¤±è´¥', {
          ip: this.getClientIP(req),
          path: req.path
        });
        
        return res.status(403).json({
          success: false,
          error: {
            code: 'CSRF_TOKEN_INVALID',
            message: 'CSRFä»¤ç‰Œæ— æ•ˆ'
          }
        });
      }
      
      next();
    };
  }

  /**
   * æ•æ„Ÿæ•°æ®åŠ å¯†
   */
  encrypt(data: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.config.encryption.algorithm, this.encryptionKey);
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return iv.toString('hex') + ':' + encrypted;
  }

  /**
   * æ•æ„Ÿæ•°æ®è§£å¯†
   */
  decrypt(encryptedData: string): string {
    const parts = encryptedData.split(':');
    const iv = Buffer.from(parts[0], 'hex');
    const encrypted = parts[1];
    const decipher = crypto.createDecipher(this.config.encryption.algorithm, this.encryptionKey);
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
  }

  private extractToken(req: Request): string | null {
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
      return authHeader.substring(7);
    }
    return req.cookies?.token || null;
  }

  private async isTokenBlacklisted(token: string): Promise<boolean> {
    // å®ç°ä»¤ç‰Œé»‘åå•æ£€æŸ¥
    // å¯ä»¥ä½¿ç”¨Rediså­˜å‚¨é»‘åå•ä»¤ç‰Œ
    return false;
  }

  private async isUserValid(userId: string): Promise<boolean> {
    // å®ç°ç”¨æˆ·æœ‰æ•ˆæ€§æ£€æŸ¥
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦è¢«ç¦ç”¨ã€åˆ é™¤ç­‰
    return true;
  }

  private getClientIP(req: Request): string {
    return req.ip || 
           req.connection.remoteAddress || 
           req.socket.remoteAddress || 
           (req.connection as any)?.socket?.remoteAddress || 
           'unknown';
  }

  private recordSuspiciousActivity(ip: string, activity: string): void {
    const record = this.suspiciousIPs.get(ip) || { attempts: 0, lastAttempt: new Date() };
    record.attempts++;
    record.lastAttempt = new Date();
    this.suspiciousIPs.set(ip, record);
    
    // å¦‚æœå¯ç–‘æ´»åŠ¨è¿‡å¤šï¼Œå¯ä»¥è€ƒè™‘è‡ªåŠ¨å°ç¦
    if (record.attempts > 10) {
      logger.error('æ£€æµ‹åˆ°é«˜é¢‘å¯ç–‘æ´»åŠ¨', {
        ip,
        activity,
        attempts: record.attempts
      });
    }
  }

  private sanitizeErrorMessage(message: string): string {
    // æ¸…ç†é”™è¯¯æ¶ˆæ¯ï¼Œé¿å…æ³„éœ²æ•æ„Ÿä¿¡æ¯
    return message.replace(/[<>"'&]/g, '');
  }

  private sanitizeValue(value: any): any {
    if (typeof value === 'string') {
      return value.replace(/[<>"'&]/g, '').substring(0, 100);
    }
    return '[sanitized]';
  }

  private sanitizeObject(obj: any): any {
    if (typeof obj === 'string') {
      return this.sanitizeValue(obj);
    }
    if (typeof obj === 'object' && obj !== null) {
      const sanitized: any = {};
      Object.keys(obj).forEach(key => {
        sanitized[key] = this.sanitizeObject(obj[key]);
      });
      return sanitized;
    }
    return obj;
  }
}
```

## ğŸ”¬ é«˜çº§æµ‹è¯•ç­–ç•¥

### 1. å¥‘çº¦æµ‹è¯•ä¸APIç‰ˆæœ¬ç®¡ç†

```typescript
// src/testing/ContractTesting.ts
import { Pact, Matchers } from '@pact-foundation/pact';
import { logger } from '../utils/logger';

export interface APIContract {
  consumer: string;
  provider: string;
  version: string;
  interactions: ContractInteraction[];
}

export interface ContractInteraction {
  description: string;
  providerState?: string;
  request: {
    method: string;
    path: string;
    headers?: Record<string, string>;
    body?: any;
  };
  response: {
    status: number;
    headers?: Record<string, string>;
    body?: any;
  };
}

export class ContractTestManager {
  private pact: Pact;
  private contracts: Map<string, APIContract> = new Map();

  constructor(consumerName: string, providerName: string) {
    this.pact = new Pact({
      consumer: consumerName,
      provider: providerName,
      port: 1234,
      log: './logs/pact.log',
      dir: './pacts',
      logLevel: 'INFO'
    });
  }

  /**
   * å®šä¹‰APIå¥‘çº¦
   */
  defineContract(contractId: string, contract: APIContract): void {
    this.contracts.set(contractId, contract);
    logger.info('APIå¥‘çº¦å·²å®šä¹‰', { contractId, consumer: contract.consumer, provider: contract.provider });
  }

  /**
   * æ‰§è¡Œå¥‘çº¦æµ‹è¯•
   */
  async runContractTests(contractId: string): Promise<boolean> {
    const contract = this.contracts.get(contractId);
    if (!contract) {
      throw new Error(`å¥‘çº¦ä¸å­˜åœ¨: ${contractId}`);
    }

    try {
      await this.pact.setup();

      for (const interaction of contract.interactions) {
        await this.pact.addInteraction({
          description: interaction.description,
          providerState: interaction.providerState,
          uponReceiving: interaction.description,
          withRequest: {
            method: interaction.request.method,
            path: interaction.request.path,
            headers: interaction.request.headers,
            body: interaction.request.body
          },
          willRespondWith: {
            status: interaction.response.status,
            headers: interaction.response.headers,
            body: interaction.response.body
          }
        });
      }

      // æ‰§è¡Œå®é™…çš„APIè°ƒç”¨æµ‹è¯•
      await this.executeAPITests(contract);

      await this.pact.verify();
      await this.pact.finalize();

      logger.info('å¥‘çº¦æµ‹è¯•é€šè¿‡', { contractId });
      return true;
    } catch (error) {
      logger.error('å¥‘çº¦æµ‹è¯•å¤±è´¥', { contractId, error: error.message });
      return false;
    }
  }

  /**
   * éªŒè¯APIå‘åå…¼å®¹æ€§
   */
  async verifyBackwardCompatibility(oldVersion: string, newVersion: string): Promise<{
    compatible: boolean;
    breakingChanges: string[];
    warnings: string[];
  }> {
    const result = {
      compatible: true,
      breakingChanges: [] as string[],
      warnings: [] as string[]
    };

    // è¿™é‡Œå®ç°APIç‰ˆæœ¬æ¯”è¾ƒé€»è¾‘
    // æ£€æŸ¥å­—æ®µåˆ é™¤ã€ç±»å‹å˜æ›´ã€å¿…å¡«å­—æ®µæ·»åŠ ç­‰
    
    return result;
  }

  private async executeAPITests(contract: APIContract): Promise<void> {
    // å®ç°å®é™…çš„APIè°ƒç”¨æµ‹è¯•
    // è¿™é‡Œåº”è¯¥è°ƒç”¨çœŸå®çš„APIç«¯ç‚¹è¿›è¡Œæµ‹è¯•
  }
}
```

### 2. æ€§èƒ½æµ‹è¯•è‡ªåŠ¨åŒ–

```typescript
// src/testing/PerformanceTesting.ts
import autocannon from 'autocannon';
import { logger } from '../utils/logger';

export interface PerformanceTestConfig {
  url: string;
  connections: number;
  duration: number;
  pipelining: number;
  headers?: Record<string, string>;
  body?: string;
  method?: string;
}

export interface PerformanceResult {
  url: string;
  timestamp: Date;
  duration: number;
  requests: {
    total: number;
    average: number;
    min: number;
    max: number;
    p50: number;
    p90: number;
    p95: number;
    p99: number;
  };
  latency: {
    average: number;
    min: number;
    max: number;
    p50: number;
    p90: number;
    p95: number;
    p99: number;
  };
  throughput: {
    average: number;
    min: number;
    max: number;
  };
  errors: number;
  timeouts: number;
}

export class PerformanceTestSuite {
  private baselineResults: Map<string, PerformanceResult> = new Map();
  private thresholds: Map<string, PerformanceThresholds> = new Map();

  /**
   * æ‰§è¡Œæ€§èƒ½æµ‹è¯•
   */
  async runPerformanceTest(testName: string, config: PerformanceTestConfig): Promise<PerformanceResult> {
    logger.info('å¼€å§‹æ€§èƒ½æµ‹è¯•', { testName, config });

    try {
      const result = await autocannon({
        url: config.url,
        connections: config.connections,
        duration: config.duration,
        pipelining: config.pipelining,
        headers: config.headers,
        body: config.body,
        method: config.method || 'GET'
      });

      const performanceResult: PerformanceResult = {
        url: config.url,
        timestamp: new Date(),
        duration: config.duration,
        requests: {
          total: result.requests.total,
          average: result.requests.average,
          min: result.requests.min,
          max: result.requests.max,
          p50: result.requests.p50,
          p90: result.requests.p90,
          p95: result.requests.p95,
          p99: result.requests.p99
        },
        latency: {
          average: result.latency.average,
          min: result.latency.min,
          max: result.latency.max,
          p50: result.latency.p50,
          p90: result.latency.p90,
          p95: result.latency.p95,
          p99: result.latency.p99
        },
        throughput: {
          average: result.throughput.average,
          min: result.throughput.min,
          max: result.throughput.max
        },
        errors: result.errors,
        timeouts: result.timeouts
      };

      // ä¸åŸºçº¿å¯¹æ¯”
      await this.compareWithBaseline(testName, performanceResult);

      logger.info('æ€§èƒ½æµ‹è¯•å®Œæˆ', {
        testName,
        requestsPerSecond: performanceResult.requests.average,
        averageLatency: performanceResult.latency.average,
        errors: performanceResult.errors
      });

      return performanceResult;
    } catch (error) {
      logger.error('æ€§èƒ½æµ‹è¯•å¤±è´¥', { testName, error: error.message });
      throw error;
    }
  }

  /**
   * è®¾ç½®æ€§èƒ½åŸºçº¿
   */
  setBaseline(testName: string, result: PerformanceResult): void {
    this.baselineResults.set(testName, result);
    logger.info('æ€§èƒ½åŸºçº¿å·²è®¾ç½®', { testName });
  }

  /**
   * è®¾ç½®æ€§èƒ½é˜ˆå€¼
   */
  setThresholds(testName: string, thresholds: PerformanceThresholds): void {
    this.thresholds.set(testName, thresholds);
    logger.info('æ€§èƒ½é˜ˆå€¼å·²è®¾ç½®', { testName, thresholds });
  }

  /**
   * ä¸åŸºçº¿å¯¹æ¯”
   */
  private async compareWithBaseline(testName: string, currentResult: PerformanceResult): Promise<void> {
    const baseline = this.baselineResults.get(testName);
    const thresholds = this.thresholds.get(testName);

    if (!baseline) {
      logger.info('æœªæ‰¾åˆ°æ€§èƒ½åŸºçº¿ï¼Œå°†å½“å‰ç»“æœè®¾ä¸ºåŸºçº¿', { testName });
      this.setBaseline(testName, currentResult);
      return;
    }

    const comparison = {
      requestsPerSecondChange: ((currentResult.requests.average - baseline.requests.average) / baseline.requests.average) * 100,
      latencyChange: ((currentResult.latency.average - baseline.latency.average) / baseline.latency.average) * 100,
      errorRateChange: currentResult.errors - baseline.errors
    };

    logger.info('æ€§èƒ½å¯¹æ¯”ç»“æœ', {
      testName,
      comparison,
      current: {
        rps: currentResult.requests.average,
        latency: currentResult.latency.average,
        errors: currentResult.errors
      },
      baseline: {
        rps: baseline.requests.average,
        latency: baseline.latency.average,
        errors: baseline.errors
      }
    });

    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é˜ˆå€¼
    if (thresholds) {
      const violations = [];
      
      if (comparison.requestsPerSecondChange < -thresholds.maxRpsDecrease) {
        violations.push(`RPSä¸‹é™è¶…è¿‡é˜ˆå€¼: ${comparison.requestsPerSecondChange.toFixed(2)}%`);
      }
      
      if (comparison.latencyChange > thresholds.maxLatencyIncrease) {
        violations.push(`å»¶è¿Ÿå¢åŠ è¶…è¿‡é˜ˆå€¼: ${comparison.latencyChange.toFixed(2)}%`);
      }
      
      if (currentResult.errors > thresholds.maxErrors) {
        violations.push(`é”™è¯¯æ•°è¶…è¿‡é˜ˆå€¼: ${currentResult.errors}`);
      }

      if (violations.length > 0) {
        logger.error('æ€§èƒ½æµ‹è¯•æœªé€šè¿‡é˜ˆå€¼æ£€æŸ¥', { testName, violations });
        throw new Error(`æ€§èƒ½å›å½’æ£€æµ‹: ${violations.join(', ')}`);
      }
    }
  }

  /**
   * ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
   */
  generateReport(results: Map<string, PerformanceResult[]>): string {
    let report = '# æ€§èƒ½æµ‹è¯•æŠ¥å‘Š\n\n';
    report += `ç”Ÿæˆæ—¶é—´: ${new Date().toISOString()}\n\n`;

    results.forEach((testResults, testName) => {
      report += `## ${testName}\n\n`;
      
      if (testResults.length > 0) {
        const latest = testResults[testResults.length - 1];
        report += `- **æœ€æ–°æµ‹è¯•æ—¶é—´**: ${latest.timestamp.toISOString()}\n`;
        report += `- **å¹³å‡RPS**: ${latest.requests.average.toFixed(2)}\n`;
        report += `- **å¹³å‡å»¶è¿Ÿ**: ${latest.latency.average.toFixed(2)}ms\n`;
        report += `- **P95å»¶è¿Ÿ**: ${latest.latency.p95.toFixed(2)}ms\n`;
        report += `- **é”™è¯¯æ•°**: ${latest.errors}\n`;
        report += `- **è¶…æ—¶æ•°**: ${latest.timeouts}\n\n`;
        
        // è¶‹åŠ¿åˆ†æ
        if (testResults.length > 1) {
          const previous = testResults[testResults.length - 2];
          const rpsChange = ((latest.requests.average - previous.requests.average) / previous.requests.average) * 100;
          const latencyChange = ((latest.latency.average - previous.latency.average) / previous.latency.average) * 100;
          
          report += `### è¶‹åŠ¿åˆ†æ\n`;
          report += `- RPSå˜åŒ–: ${rpsChange > 0 ? '+' : ''}${rpsChange.toFixed(2)}%\n`;
          report += `- å»¶è¿Ÿå˜åŒ–: ${latencyChange > 0 ? '+' : ''}${latencyChange.toFixed(2)}%\n\n`;
        }
      }
    });

    return report;
  }
}

interface PerformanceThresholds {
  maxRpsDecrease: number; // æœ€å¤§RPSä¸‹é™ç™¾åˆ†æ¯”
  maxLatencyIncrease: number; // æœ€å¤§å»¶è¿Ÿå¢åŠ ç™¾åˆ†æ¯”
  maxErrors: number; // æœ€å¤§é”™è¯¯æ•°
}
```

## ğŸ“Š æ™ºèƒ½ç›‘æ§ä¸å¯è§‚æµ‹æ€§

### 1. åˆ†å¸ƒå¼è¿½è¸ªç³»ç»Ÿ

```typescript
// src/monitoring/DistributedTracing.ts
import { trace, context, SpanStatusCode, SpanKind } from '@opentelemetry/api';
import { NodeSDK } from '@opentelemetry/sdk-node';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
import { JaegerExporter } from '@opentelemetry/exporter-jaeger';
import { logger } from '../utils/logger';

export interface TraceConfig {
  serviceName: string;
  serviceVersion: string;
  jaegerEndpoint: string;
  samplingRate: number;
}

export class DistributedTracingManager {
  private sdk: NodeSDK;
  private tracer: any;
  private config: TraceConfig;

  constructor(config: TraceConfig) {
    this.config = config;
    this.initializeTracing();
  }

  private initializeTracing(): void {
    const jaegerExporter = new JaegerExporter({
      endpoint: this.config.jaegerEndpoint
    });

    this.sdk = new NodeSDK({
      resource: new Resource({
        [SemanticResourceAttributes.SERVICE_NAME]: this.config.serviceName,
        [SemanticResourceAttributes.SERVICE_VERSION]: this.config.serviceVersion
      }),
      traceExporter: jaegerExporter,
      samplingRate: this.config.samplingRate
    });

    this.sdk.start();
    this.tracer = trace.getTracer(this.config.serviceName, this.config.serviceVersion);
    
    logger.info('åˆ†å¸ƒå¼è¿½è¸ªå·²åˆå§‹åŒ–', {
      serviceName: this.config.serviceName,
      jaegerEndpoint: this.config.jaegerEndpoint
    });
  }

  /**
   * åˆ›å»ºè¿½è¸ªspan
   */
  createSpan(name: string, options?: {
    kind?: SpanKind;
    attributes?: Record<string, any>;
    parent?: any;
  }) {
    const span = this.tracer.startSpan(name, {
      kind: options?.kind || SpanKind.INTERNAL,
      attributes: options?.attributes,
      parent: options?.parent
    });

    return {
      span,
      setStatus: (code: SpanStatusCode, message?: string) => {
        span.setStatus({ code, message });
      },
      setAttribute: (key: string, value: any) => {
        span.setAttribute(key, value);
      },
      addEvent: (name: string, attributes?: Record<string, any>) => {
        span.addEvent(name, attributes);
      },
      end: () => {
        span.end();
      }
    };
  }

  /**
   * HTTPè¯·æ±‚è¿½è¸ªä¸­é—´ä»¶
   */
  httpTracingMiddleware() {
    return (req: any, res: any, next: any) => {
      const spanName = `${req.method} ${req.route?.path || req.path}`;
      const span = this.createSpan(spanName, {
        kind: SpanKind.SERVER,
        attributes: {
          'http.method': req.method,
          'http.url': req.url,
          'http.route': req.route?.path,
          'http.user_agent': req.headers['user-agent'],
          'user.id': req.user?.id
        }
      });

      // å°†spanæ·»åŠ åˆ°è¯·æ±‚ä¸Šä¸‹æ–‡
      req.span = span;

      // ç›‘å¬å“åº”å®Œæˆ
      res.on('finish', () => {
        span.setAttribute('http.status_code', res.statusCode);
        span.setAttribute('http.response_size', res.get('content-length') || 0);
        
        if (res.statusCode >= 400) {
          span.setStatus(SpanStatusCode.ERROR, `HTTP ${res.statusCode}`);
        } else {
          span.setStatus(SpanStatusCode.OK);
        }
        
        span.end();
      });

      next();
    };
  }

  /**
   * æ•°æ®åº“æŸ¥è¯¢è¿½è¸ª
   */
  traceDatabase<T>(operation: string, query: string, executor: () => Promise<T>): Promise<T> {
    const span = this.createSpan(`db.${operation}`, {
      kind: SpanKind.CLIENT,
      attributes: {
        'db.system': 'postgresql', // æˆ–å…¶ä»–æ•°æ®åº“ç±»å‹
        'db.operation': operation,
        'db.statement': query
      }
    });

    return context.with(trace.setSpan(context.active(), span.span), async () => {
      try {
        const result = await executor();
        span.setStatus(SpanStatusCode.OK);
        return result;
      } catch (error) {
        span.setStatus(SpanStatusCode.ERROR, error.message);
        span.setAttribute('error', true);
        span.setAttribute('error.message', error.message);
        throw error;
      } finally {
        span.end();
      }
    });
  }

  /**
   * å¤–éƒ¨APIè°ƒç”¨è¿½è¸ª
   */
  traceExternalAPI<T>(serviceName: string, endpoint: string, executor: () => Promise<T>): Promise<T> {
    const span = this.createSpan(`external.${serviceName}`, {
      kind: SpanKind.CLIENT,
      attributes: {
        'http.url': endpoint,
        'service.name': serviceName
      }
    });

    return context.with(trace.setSpan(context.active(), span.span), async () => {
      try {
        const startTime = Date.now();
        const result = await executor();
        const duration = Date.now() - startTime;
        
        span.setAttribute('http.duration', duration);
        span.setStatus(SpanStatusCode.OK);
        return result;
      } catch (error) {
        span.setStatus(SpanStatusCode.ERROR, error.message);
        span.setAttribute('error', true);
        span.setAttribute('error.message', error.message);
        throw error;
      } finally {
        span.end();
      }
    });
  }

  /**
   * ä¸šåŠ¡é€»è¾‘è¿½è¸ªè£…é¥°å™¨
   */
  trace(operationName?: string) {
    return (target: any, propertyName: string, descriptor: PropertyDescriptor) => {
      const method = descriptor.value;
      const spanName = operationName || `${target.constructor.name}.${propertyName}`;

      descriptor.value = async function (...args: any[]) {
        const span = this.tracingManager.createSpan(spanName, {
          attributes: {
            'operation.name': spanName,
            'operation.args_count': args.length
          }
        });

        return context.with(trace.setSpan(context.active(), span.span), async () => {
          try {
            const result = await method.apply(this, args);
            span.setStatus(SpanStatusCode.OK);
            return result;
          } catch (error) {
            span.setStatus(SpanStatusCode.ERROR, error.message);
            span.setAttribute('error', true);
            span.setAttribute('error.message', error.message);
            throw error;
          } finally {
            span.end();
          }
        });
      };

      return descriptor;
    };
  }

  /**
   * è·å–å½“å‰è¿½è¸ªä¸Šä¸‹æ–‡
   */
  getCurrentSpan() {
    return trace.getActiveSpan();
  }

  /**
   * å…³é—­è¿½è¸ªç³»ç»Ÿ
   */
  async shutdown(): Promise<void> {
    await this.sdk.shutdown();
    logger.info('åˆ†å¸ƒå¼è¿½è¸ªå·²å…³é—­');
  }
}
```

### 2. æ™ºèƒ½å‘Šè­¦ç³»ç»Ÿ

```typescript
// src/monitoring/AlertingSystem.ts
import { logger } from '../utils/logger';

export interface AlertRule {
  id: string;
  name: string;
  description: string;
  metric: string;
  condition: 'gt' | 'lt' | 'eq' | 'gte' | 'lte';
  threshold: number;
  duration: number; // æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
  severity: 'low' | 'medium' | 'high' | 'critical';
  channels: AlertChannel[];
  enabled: boolean;
  tags: string[];
}

export interface AlertChannel {
  type: 'email' | 'slack' | 'webhook' | 'sms';
  config: Record<string, any>;
}

export interface Alert {
  id: string;
  ruleId: string;
  metric: string;
  value: number;
  threshold: number;
  severity: string;
  message: string;
  timestamp: Date;
  resolved: boolean;
  resolvedAt?: Date;
}

export class IntelligentAlertingSystem {
  private rules: Map<string, AlertRule> = new Map();
  private activeAlerts: Map<string, Alert> = new Map();
  private metricHistory: Map<string, Array<{ value: number; timestamp: Date }>> = new Map();
  private channels: Map<string, AlertChannel> = new Map();
  private suppressionRules: Map<string, Date> = new Map();

  /**
   * æ·»åŠ å‘Šè­¦è§„åˆ™
   */
  addRule(rule: AlertRule): void {
    this.rules.set(rule.id, rule);
    logger.info('å‘Šè­¦è§„åˆ™å·²æ·»åŠ ', { ruleId: rule.id, name: rule.name });
  }

  /**
   * æ£€æŸ¥æŒ‡æ ‡å¹¶è§¦å‘å‘Šè­¦
   */
  async checkMetric(metric: string, value: number): Promise<void> {
    // è®°å½•æŒ‡æ ‡å†å²
    this.recordMetric(metric, value);

    // æ£€æŸ¥æ‰€æœ‰ç›¸å…³è§„åˆ™
    const relevantRules = Array.from(this.rules.values())
      .filter(rule => rule.enabled && rule.metric === metric);

    for (const rule of relevantRules) {
      await this.evaluateRule(rule, value);
    }
  }

  /**
   * è¯„ä¼°å‘Šè­¦è§„åˆ™
   */
  private async evaluateRule(rule: AlertRule, currentValue: number): Promise<void> {
    const isTriggered = this.evaluateCondition(rule.condition, currentValue, rule.threshold);
    const alertKey = `${rule.id}_${rule.metric}`;
    const existingAlert = this.activeAlerts.get(alertKey);

    if (isTriggered) {
      if (!existingAlert) {
        // æ£€æŸ¥æ˜¯å¦æ»¡è¶³æŒç»­æ—¶é—´è¦æ±‚
        if (await this.checkDuration(rule, currentValue)) {
          await this.triggerAlert(rule, currentValue);
        }
      } else {
        // æ›´æ–°ç°æœ‰å‘Šè­¦
        existingAlert.value = currentValue;
        existingAlert.timestamp = new Date();
      }
    } else if (existingAlert && !existingAlert.resolved) {
      // è§£å†³å‘Šè­¦
      await this.resolveAlert(existingAlert);
    }
  }

  /**
   * è§¦å‘å‘Šè­¦
   */
  private async triggerAlert(rule: AlertRule, value: number): Promise<void> {
    const alertId = `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const alert: Alert = {
      id: alertId,
      ruleId: rule.id,
      metric: rule.metric,
      value,
      threshold: rule.threshold,
      severity: rule.severity,
      message: this.generateAlertMessage(rule, value),
      timestamp: new Date(),
      resolved: false
    };

    const alertKey = `${rule.id}_${rule.metric}`;
    this.activeAlerts.set(alertKey, alert);

    // æ£€æŸ¥æŠ‘åˆ¶è§„åˆ™
    if (this.isAlertSuppressed(rule)) {
      logger.info('å‘Šè­¦è¢«æŠ‘åˆ¶', { alertId, ruleId: rule.id });
      return;
    }

    // å‘é€å‘Šè­¦é€šçŸ¥
    await this.sendAlertNotifications(alert, rule);

    logger.error('å‘Šè­¦å·²è§¦å‘', {
      alertId,
      ruleId: rule.id,
      metric: rule.metric,
      value,
      threshold: rule.threshold,
      severity: rule.severity
    });
  }

  /**
   * è§£å†³å‘Šè­¦
   */
  private async resolveAlert(alert: Alert): Promise<void> {
    alert.resolved = true;
    alert.resolvedAt = new Date();

    const rule = this.rules.get(alert.ruleId);
    if (rule) {
      await this.sendResolutionNotifications(alert, rule);
    }

    logger.info('å‘Šè­¦å·²è§£å†³', {
      alertId: alert.id,
      ruleId: alert.ruleId,
      duration: alert.resolvedAt.getTime() - alert.timestamp.getTime()
    });
  }

  /**
   * å‘é€å‘Šè­¦é€šçŸ¥
   */
  private async sendAlertNotifications(alert: Alert, rule: AlertRule): Promise<void> {
    const notifications = rule.channels.map(async (channel) => {
      try {
        await this.sendNotification(channel, alert, rule);
      } catch (error) {
        logger.error('å‘Šè­¦é€šçŸ¥å‘é€å¤±è´¥', {
          alertId: alert.id,
          channelType: channel.type,
          error: error.message
        });
      }
    });

    await Promise.allSettled(notifications);
  }

  /**
   * å‘é€é€šçŸ¥
   */
  private async sendNotification(channel: AlertChannel, alert: Alert, rule: AlertRule): Promise<void> {
    switch (channel.type) {
      case 'email':
        await this.sendEmailNotification(channel, alert, rule);
        break;
      case 'slack':
        await this.sendSlackNotification(channel, alert, rule);
        break;
      case 'webhook':
        await this.sendWebhookNotification(channel, alert, rule);
        break;
      case 'sms':
        await this.sendSMSNotification(channel, alert, rule);
        break;
    }
  }

  private async sendEmailNotification(channel: AlertChannel, alert: Alert, rule: AlertRule): Promise<void> {
    // å®ç°é‚®ä»¶é€šçŸ¥
    logger.info('é‚®ä»¶å‘Šè­¦é€šçŸ¥å·²å‘é€', { alertId: alert.id, to: channel.config.to });
  }

  private async sendSlackNotification(channel: AlertChannel, alert: Alert, rule: AlertRule): Promise<void> {
    // å®ç°Slacké€šçŸ¥
    logger.info('Slackå‘Šè­¦é€šçŸ¥å·²å‘é€', { alertId: alert.id, channel: channel.config.channel });
  }

  private async sendWebhookNotification(channel: AlertChannel, alert: Alert, rule: AlertRule): Promise<void> {
    // å®ç°Webhooké€šçŸ¥
    logger.info('Webhookå‘Šè­¦é€šçŸ¥å·²å‘é€', { alertId: alert.id, url: channel.config.url });
  }

  private async sendSMSNotification(channel: AlertChannel, alert: Alert, rule: AlertRule): Promise<void> {
    // å®ç°SMSé€šçŸ¥
    logger.info('SMSå‘Šè­¦é€šçŸ¥å·²å‘é€', { alertId: alert.id, phone: channel.config.phone });
  }

  private evaluateCondition(condition: string, value: number, threshold: number): boolean {
    switch (condition) {
      case 'gt': return value > threshold;
      case 'gte': return value >= threshold;
      case 'lt': return value < threshold;
      case 'lte': return value <= threshold;
      case 'eq': return value === threshold;
      default: return false;
    }
  }

  private async checkDuration(rule: AlertRule, value: number): Promise<boolean> {
    const history = this.metricHistory.get(rule.metric) || [];
    const cutoffTime = new Date(Date.now() - rule.duration * 1000);
    
    const recentValues = history.filter(entry => entry.timestamp >= cutoffTime);
    return recentValues.every(entry => 
      this.evaluateCondition(rule.condition, entry.value, rule.threshold)
    );
  }

  private recordMetric(metric: string, value: number): void {
    if (!this.metricHistory.has(metric)) {
      this.metricHistory.set(metric, []);
    }
    
    const history = this.metricHistory.get(metric)!;
    history.push({ value, timestamp: new Date() });
    
    // ä¿ç•™æœ€è¿‘1å°æ—¶çš„æ•°æ®
    const cutoffTime = new Date(Date.now() - 3600000);
    this.metricHistory.set(metric, history.filter(entry => entry.timestamp >= cutoffTime));
  }

  private generateAlertMessage(rule: AlertRule, value: number): string {
    return `å‘Šè­¦: ${rule.name} - ${rule.metric} å½“å‰å€¼ ${value} ${rule.condition} é˜ˆå€¼ ${rule.threshold}`;
  }

  private isAlertSuppressed(rule: AlertRule): boolean {
    const suppressionKey = `${rule.id}_${rule.metric}`;
    const suppressedUntil = this.suppressionRules.get(suppressionKey);
    return suppressedUntil ? new Date() < suppressedUntil : false;
  }

  /**
   * æŠ‘åˆ¶å‘Šè­¦
   */
  suppressAlert(ruleId: string, metric: string, duration: number): void {
    const suppressionKey = `${ruleId}_${metric}`;
    const suppressedUntil = new Date(Date.now() + duration * 1000);
    this.suppressionRules.set(suppressionKey, suppressedUntil);
    logger.info('å‘Šè­¦å·²æŠ‘åˆ¶', { ruleId, metric, duration });
  }

  /**
   * è·å–æ´»è·ƒå‘Šè­¦
   */
  getActiveAlerts(): Alert[] {
    return Array.from(this.activeAlerts.values()).filter(alert => !alert.resolved);
  }

  /**
   * è·å–å‘Šè­¦ç»Ÿè®¡
   */
  getAlertStats(): {
    total: number;
    bySeverity: Record<string, number>;
    byMetric: Record<string, number>;
    resolved: number;
  } {
    const allAlerts = Array.from(this.activeAlerts.values());
    
    return {
      total: allAlerts.length,
      bySeverity: this.groupBy(allAlerts, 'severity'),
      byMetric: this.groupBy(allAlerts, 'metric'),
      resolved: allAlerts.filter(alert => alert.resolved).length
    };
  }

  private groupBy(items: any[], key: string): Record<string, number> {
    return items.reduce((acc, item) => {
      const value = item[key];
      acc[value] = (acc[value] || 0) + 1;
      return acc;
    }, {});
  }

  private async sendResolutionNotifications(alert: Alert, rule: AlertRule): Promise<void> {
    // å®ç°å‘Šè­¦è§£å†³é€šçŸ¥
    logger.info('å‘Šè­¦è§£å†³é€šçŸ¥å·²å‘é€', { alertId: alert.id });
  }
}
```

## ğŸš€ å®æ–½ä¼˜å…ˆçº§ä¸è·¯çº¿å›¾

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€æ¶æ„ç°ä»£åŒ–ï¼ˆ1-2å‘¨ï¼‰

#### ç«‹å³å®æ–½ï¼ˆæœ¬å‘¨ï¼‰
1. **äº‹ä»¶é©±åŠ¨æ¶æ„åŸºç¡€**
   - å®ç° `EventBus` ç±»
   - åˆ›å»ºåŸºç¡€äº‹ä»¶å¤„ç†å™¨
   - é›†æˆåˆ°ç°æœ‰ä¸šåŠ¡é€»è¾‘

2. **å¤šå±‚ç¼“å­˜ç³»ç»Ÿ**
   - éƒ¨ç½² `CacheManager`
   - é…ç½®Redisè¿æ¥
   - å®ç°ç¼“å­˜é¢„çƒ­ç­–ç•¥

#### ä¸‹å‘¨ç›®æ ‡
1. **å®‰å…¨ä¸­é—´ä»¶å‡çº§**
   - éƒ¨ç½² `SecurityMiddleware`
   - é…ç½®æ™ºèƒ½é€Ÿç‡é™åˆ¶
   - å®ç°è¾“å…¥éªŒè¯å’Œæ¸…ç†

2. **åˆ†å¸ƒå¼è¿½è¸ª**
   - é›†æˆOpenTelemetry
   - é…ç½®Jaeger
   - æ·»åŠ å…³é”®ä¸šåŠ¡æµç¨‹è¿½è¸ª

### ç¬¬äºŒé˜¶æ®µï¼šæµ‹è¯•ä¸ç›‘æ§å®Œå–„ï¼ˆ3-4å‘¨ï¼‰

#### ç¬¬3å‘¨ï¼šé«˜çº§æµ‹è¯•ç­–ç•¥
1. **å¥‘çº¦æµ‹è¯•å®æ–½**
   - å®šä¹‰APIå¥‘çº¦
   - å®ç°å¥‘çº¦æµ‹è¯•å¥—ä»¶
   - é›†æˆåˆ°CI/CDæµç¨‹

2. **æ€§èƒ½æµ‹è¯•è‡ªåŠ¨åŒ–**
   - éƒ¨ç½²æ€§èƒ½æµ‹è¯•å¥—ä»¶
   - è®¾ç½®æ€§èƒ½åŸºçº¿
   - é…ç½®æ€§èƒ½å›å½’æ£€æµ‹

#### ç¬¬4å‘¨ï¼šæ™ºèƒ½ç›‘æ§
1. **å‘Šè­¦ç³»ç»Ÿéƒ¨ç½²**
   - é…ç½®å‘Šè­¦è§„åˆ™
   - é›†æˆé€šçŸ¥æ¸ é“
   - å®ç°å‘Šè­¦æŠ‘åˆ¶é€»è¾‘

2. **å¯è§‚æµ‹æ€§å®Œå–„**
   - å®Œå–„åˆ†å¸ƒå¼è¿½è¸ª
   - æ·»åŠ ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§
   - å®ç°å¥åº·æ£€æŸ¥ç«¯ç‚¹

### ç¬¬ä¸‰é˜¶æ®µï¼šå¾®æœåŠ¡å‡†å¤‡ï¼ˆ5-6å‘¨ï¼‰

#### æœåŠ¡è¾¹ç•Œå®šä¹‰
1. **é¢†åŸŸå»ºæ¨¡**
   - è¯†åˆ«ä¸šåŠ¡è¾¹ç•Œ
   - å®šä¹‰æœåŠ¡æ¥å£
   - è§„åˆ’æ•°æ®è¿ç§»ç­–ç•¥

2. **APIç‰ˆæœ¬ç®¡ç†**
   - å®ç°APIç‰ˆæœ¬æ§åˆ¶
   - é…ç½®å‘åå…¼å®¹æ€§æ£€æŸ¥
   - å‡†å¤‡æ¸è¿›å¼è¿ç§»

## ğŸ“ˆ é¢„æœŸæ”¶ç›Šä¸æˆåŠŸæŒ‡æ ‡

### æŠ€æœ¯æ”¶ç›Š
- **æ€§èƒ½æå‡**: å“åº”æ—¶é—´å‡å°‘40-60%
- **å¯é æ€§å¢å¼º**: ç³»ç»Ÿå¯ç”¨æ€§è¾¾åˆ°99.9%+
- **å®‰å…¨åŠ å›º**: å®‰å…¨æ¼æ´å‡å°‘90%+
- **å¯ç»´æŠ¤æ€§**: ä»£ç å¤æ‚åº¦é™ä½50%

### ä¸šåŠ¡æ”¶ç›Š
- **å¼€å‘æ•ˆç‡**: æ–°åŠŸèƒ½äº¤ä»˜é€Ÿåº¦æå‡50%
- **é—®é¢˜è§£å†³**: æ•…éšœå®šä½æ—¶é—´å‡å°‘70%
- **ç”¨æˆ·ä½“éªŒ**: é¡µé¢åŠ è½½é€Ÿåº¦æå‡60%
- **è¿ç»´æˆæœ¬**: äººå·¥å¹²é¢„å‡å°‘80%

### å…³é”®æˆåŠŸæŒ‡æ ‡
1. **ä»£ç è´¨é‡æŒ‡æ ‡**
   - ä»£ç è¦†ç›–ç‡ > 85%
   - åœˆå¤æ‚åº¦ < 10
   - æŠ€æœ¯å€ºåŠ¡ < 5%

2. **æ€§èƒ½æŒ‡æ ‡**
   - APIå“åº”æ—¶é—´ < 200ms (P95)
   - ç¼“å­˜å‘½ä¸­ç‡ > 90%
   - æ•°æ®åº“æŸ¥è¯¢æ—¶é—´ < 50ms

3. **å¯é æ€§æŒ‡æ ‡**
   - ç³»ç»Ÿå¯ç”¨æ€§ > 99.9%
   - é”™è¯¯ç‡ < 0.1%
   - æ¢å¤æ—¶é—´ < 5åˆ†é’Ÿ

## ğŸ¯ ä¸‹ä¸€æ­¥è¡ŒåŠ¨å»ºè®®

### ç«‹å³å¼€å§‹ï¼ˆä»Šå¤©ï¼‰
1. **åˆ›å»ºå¼€å‘åˆ†æ”¯**: `feature/enterprise-architecture`
2. **å®‰è£…ä¾èµ–åŒ…**: OpenTelemetry, Redis, å®‰å…¨ä¸­é—´ä»¶
3. **é…ç½®å¼€å‘ç¯å¢ƒ**: Jaeger, RedisæœåŠ¡

### æœ¬å‘¨å®Œæˆ
1. **å®ç°äº‹ä»¶æ€»çº¿**: æ ¸å¿ƒEventBusç±»å’ŒåŸºç¡€äº‹ä»¶å¤„ç†
2. **éƒ¨ç½²ç¼“å­˜ç³»ç»Ÿ**: å¤šå±‚ç¼“å­˜æ¶æ„å’Œé¢„çƒ­ç­–ç•¥
3. **å®‰å…¨ä¸­é—´ä»¶**: åŸºç¡€å®‰å…¨é˜²æŠ¤å’Œè¾“å…¥éªŒè¯

### æœ¬æœˆç›®æ ‡
1. **å®Œæ•´ç›‘æ§ä½“ç³»**: åˆ†å¸ƒå¼è¿½è¸ªå’Œæ™ºèƒ½å‘Šè­¦
2. **æµ‹è¯•è‡ªåŠ¨åŒ–**: å¥‘çº¦æµ‹è¯•å’Œæ€§èƒ½æµ‹è¯•
3. **æ–‡æ¡£å®Œå–„**: APIæ–‡æ¡£å’Œè¿ç»´æ‰‹å†Œ

## ğŸ’¡ ä¸“å®¶å»ºè®®

### å¯¹æ¨è€å¸ˆçš„ç‰¹åˆ«å»ºè®®
1. **æ¸è¿›å¼å®æ–½**: ä¸è¦ä¸€æ¬¡æ€§æ”¹åŠ¨è¿‡å¤šï¼Œç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§
2. **å›¢é˜ŸåŸ¹è®­**: å®‰æ’å›¢é˜Ÿå­¦ä¹ æ–°æŠ€æœ¯å’Œæœ€ä½³å®è·µ
3. **ç›‘æ§å…ˆè¡Œ**: åœ¨é‡æ„å‰å…ˆå»ºç«‹å®Œå–„çš„ç›‘æ§ä½“ç³»
4. **å¤‡ä»½ç­–ç•¥**: ç¡®ä¿æœ‰å®Œæ•´çš„å›æ»šæ–¹æ¡ˆ

### é£é™©æ§åˆ¶
1. **åŠŸèƒ½å¼€å…³**: ä½¿ç”¨ç‰¹æ€§å¼€å…³æ§åˆ¶æ–°åŠŸèƒ½å‘å¸ƒ
2. **ç°åº¦å‘å¸ƒ**: é€æ­¥æ¨å¹¿æ–°æ¶æ„åˆ°ç”Ÿäº§ç¯å¢ƒ
3. **æ€§èƒ½åŸºçº¿**: å»ºç«‹æ€§èƒ½åŸºçº¿ï¼Œç›‘æ§å›å½’
4. **åº”æ€¥é¢„æ¡ˆ**: å‡†å¤‡å¿«é€Ÿå›æ»šå’Œæ•…éšœæ¢å¤æ–¹æ¡ˆ

### é•¿æœŸæ„¿æ™¯
è¿™å¥—ä¼ä¸šçº§æ¶æ„å°†ä¸º3AIé¡¹ç›®æä¾›ï¼š
- **å¯æ‰©å±•æ€§**: æ”¯æŒä¸šåŠ¡å¿«é€Ÿå¢é•¿
- **å¯ç»´æŠ¤æ€§**: é™ä½é•¿æœŸç»´æŠ¤æˆæœ¬
- **å¯è§‚æµ‹æ€§**: å…¨é¢çš„ç³»ç»Ÿæ´å¯Ÿèƒ½åŠ›
- **å®‰å…¨æ€§**: ä¼ä¸šçº§å®‰å…¨é˜²æŠ¤
- **æ€§èƒ½**: é«˜æ€§èƒ½å’Œé«˜å¯ç”¨æ€§

---

**æ¨è€å¸ˆï¼Œè¿™ä»½ä¼ä¸šçº§ç°ä»£åŒ–æŒ‡å—å°†å¸®åŠ©3AIé¡¹ç›®è¾¾åˆ°è¡Œä¸šé¢†å…ˆæ°´å¹³ã€‚å»ºè®®ä»äº‹ä»¶é©±åŠ¨æ¶æ„å’Œç¼“å­˜ç³»ç»Ÿå¼€å§‹å®æ–½ï¼Œé€æ­¥å®Œå–„æ•´ä¸ªæŠ€æœ¯æ ˆã€‚æˆ‘å°†æŒç»­æä¾›æŠ€æœ¯æ”¯æŒï¼Œç¡®ä¿å®æ–½è¿‡ç¨‹é¡ºåˆ©è¿›è¡Œã€‚**